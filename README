NAME
    gits - The git slave repository tool

SYNOPSIS
    gits [--version] [--no-master] [--no-commit] [--keep-going] [--parallel
    count] [--no-progress] [-v|--verbose]+ [--quiet] [--help] <subcommand>
    [args]...

OVERVIEW
    gits is a program which assists in assembling a meta-project from a
    number of individual git repositories which you own and operate as if it
    were one git repository instead of many, similar to how CVS works by
    default and svn (v1.5) can be coerced to work. Some of these individual
    git repositories may be part of other meta-projects as well.

    Unfortunately, the functionality provided by git-submodule is not
    sufficient for this mode of operation. Most git commands, like checkout
    or commit, do not recursively descend into the submodules so you are
    forced to do execute all git commands N+1 times (leading to pain and
    mistakes), also, submodules revisions are tracked in the supermodule so
    that change to the slave project made outside the superproject are not
    automatically seen. Since git does not allow partial checkouts, we are
    left with little alternative.

    Thus, to solve these problems gits was born. Complexity pain is still
    involved, but the hope is that it is minimized compared to all of the
    other alternatives.

    The basic theory is that there are a few sub-commands (prepare, attach,
    populate) which help set up the meta-project for gits operations. Then,
    for any git command which is not file specific (git add <filename>; git
    reset <filename>; etc), you should use "gits" instead of "git", and the
    command will run on all repositories in the project.

  Example Usage
    In the following example, we will have the following master
    repositories:

      ssh://sourcemaster/src/repos/super.git
      ssh://sourcemaster/src/repos/lib1.git
      ssh://sourcemaster/src/repos/lib2.git

    The desired working layout of directories with .git in them on disk is:

      ..../super
      ..../super/lib1
      ..../super/lib2

   Initialize a gits project
    gits prepare

    You run this command in the git directory which will be your top level
    master repository (super here). Typically you would clone this top level
    master from some other location which has all of your git projects.

      --------------------------------------------------
      git clone ssh://sourcemaster/src/repos/super.git super
      cd super
      gits prepare
      --------------------------------------------------

   Add a slave repository to top level master
      gits attach <repository> <localpath>

    Clone the named git repository into the named local directory, and set
    it up for further gits operations.

    Typically <localpath> would be a path relative to the top level working
    directory, for example, a subdirectory in the top level.

    <repository> can also be relative (relative to the URL the top level
    master checkout was cloned from). It may also be an absolute URL. If the
    URL starts with ^, it will use only the method and hostname from the
    master's URL. Otherwise, it will be relative to the fully qualified
    path. We will show both in operation in the example.

     --------------------------------------------------
     gits attach ../lib1.git lib1
     gits attach ^/src/repos/lib2.git lib2
     --------------------------------------------------

   Check out any new slave modules which someone else might have added
      gits populate

    Go through the list of configured slaves and check out (clone) any which
    have not already been retrieved.

      --------------------------------------------------
      gits populate
      --------------------------------------------------

   Perform a pull operation for all tracked branches
      gits pulls <args>

    For each branch being tracked by the superproject, go through the list
    of configured slaves, check yourself out to the branch, perform a pull,
    then switch back to the branch you were on.

      --------------------------------------------------
      gits pulls --rebase
      --------------------------------------------------

   Perform an arbitrary command for all tracked branches
      gits exec <command> [args]

    For each slave being tracked by the superproject and the superproject
    itself, cd to the root of the project directory and execute the listed
    command.

      --------------------------------------------------
      gits exec gitk
      --------------------------------------------------

   Print out URLs for arbitrary repositories like those used by attach
      gits resolve <repository>...

    Go through the same process that gits uses for resolving relative
    repository URLs into absolute URLs, for debugging and certain porting
    efforts.

      --------------------------------------------------
      gits resolve ../otherpos
      --------------------------------------------------

   Update the URL a remote repository points at
      gits update-remote-url <remote-name> <url>

    Update the super-project's remote.name.url using the url and remote name
    listed above. Then go though each slave repository and update its url
    using the normal relative url mechanism.

    Very useful when making another copy of a local repository mirroring a
    remote repository which you wish to have the copy also point to the
    remote repository.

      --------------------------------------------------
      gits update-remote-url origin ssh://git/src/git
      --------------------------------------------------

   Push a change to a remote repository
      gits push [--quick] [standard args]

    This is the standard git push command--with the addition of a --quick
    option which will only attempt to push for branches which have
    outstanding changes. For slow connections to large number of slave
    repositories, the overhead of an empty push can be large.

    However, --quick only checks to see if the CURRENT branch needs to push
    data. If you have changes on other branches, a slow push is still
    required, as it is if you are pushing to someplace other than your
    standard origin.

      --------------------------------------------------
      gits push --quick
      --------------------------------------------------

   Everything else
    All other commands are passed directly though to git, with one command
    being run per repository. Output summarizing is performed so that
    multiple repositories with the same git output will only have the git
    output shown once. `git status` has a more aggressive summarizing to
    merge the lists of files in each section.

      Examples:
      --------------------------------------------------
      gits commit -a -m "This is a change"
      gits push
      gits pull
      gits branch testing
      gits checkout testing
      gits diff master testing
      gits status
      gits ....
      --------------------------------------------------

    All normal git commands are supported (plus any potential future
    commands) but not all commands make sense to run with gits. One good
    example is git-daemon.

DESCRIPTION
  --no-master
    This flag requests that gits only run the listed command on the slave
    repositories and NOT the super/master/top repository. This probably will
    not be needed much.

  --no-progress
    This flag requests that gits NOT print a progress bar, which it does by
    default for slow operations if Term::ProgressBar is loaded. Slow
    operations are defined as: checkout, pulls, push. You may use this flag
    for all operations.

  --parallel count
    Specify the number of parallel git operations you wish to execute.
    Parallelism is only activated for "push" and "pulls" subcommands. This
    can speed up your processing quite nicely if you have large numbers of
    submodules.

    If your repositories are accessed over ssh, you may also wish to
    activate ssh "ControlMaster" multiplexing.

      ssh_config
      --------------------------------------------------
      Host git
         ControlMaster auto
         ControlPath ~/.ssh/master-%r@%h:%p
      --------------------------------------------------

    However, there currently is a "auto" race condition so the first batch
    of peers do not necessarily take advantage of the multiplexing and there
    have occassionally been spurious errors with this enabled.

  --no-commit
    This flag requests that gits-internal sub-commands, such as prepare or
    attach should not commit their changes after they made them.

  --keep-going
    Do not abort when a subsidiary git command fails for most commands,
    instead print a warning and continue processing.

  --verbose -v
    Ask for more information about what is happening. You may repeat the
    flag multiple times to get more information. Two levels of verbosity
    typically prints the underlying commands being executed and the data
    being returned from them.

  --quiet
    Ask for less information, which currently means discarding the STDERR of
    some of the administrative git commands which are executed.

  subcommand args...
    Run the specified git command (with associated arguments) on the
    repository and all slave repositories. Typically they are git commands
    run over each slave, but there are gits specific commands such as:
    prepare, attach, populate, resolve, exec, and update-remote-url. See
    OVERVIEW for more information on specific subcommands.

BUGS
    gits changes directory to the directory where .gitslave exists.
    Likewise, when executing most git commands, gits changes directory to
    the root of the git slave, so any pathnames being passed in to gits must
    be absolute, not relative. Generally this is only a concern for
    pre-generate commit messages or something, you should NOT be passing
    files checked into git in a gits command--you will likely get the wrong
    result.

FILES
  .gitslave
    The file containing the list of slave repositories (possibly in relative
    form) and the directories relative to the master root where they should
    be checked out.

ENVIRONMENT
  $GITSLAVE
    Allow overriding on the name of the .gitslave file (for supplemental
    activity, the .gitslave file must still exist even if it is not used for
    this particular operation). Also, allows a comma-space separated list of
    files names, the sum of which will be the list of slaves to use.

    An example ".gitslave, .gitslave-extras" would allow an supplemental
    list of slaves for unusual activity (e.g. release tagging) to the normal
    list.

    Alternately, you could play tricks where you only get a subset of the
    modules when you don't need to play with everything.

AUTHOR
    Seth Robertson

REPORTING BUGS
    Report bugs to <projectbaka@baka.org>

COPYRIGHT
    Copyright (c) 2008 Seth Robertson. License is similar to the GNU Lesser
    General Public License version 2.1, see LICENSE.TXT for more details.

SEE ALSO
    git(1)

