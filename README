NAME
    gits - The git slave repository tool

SYNOPSIS
    gits [--version] [--no-master] [--no-commit] [--keep-going]
    [--no-progress] [-p|--parallel <count>] [-v|--verbose]+ [--quiet]
    [--help] <subcommand> [args]...

OVERVIEW
    gits is a program that assists in assembling a meta-project from a
    number of individual git repositories which operate as if they were one
    git repository instead of many, similar to the way that CVS works by
    default and svn (v1.5) can be coerced to work. Some of these individual
    git repositories may be part of other meta-projects as well.

    Unfortunately, the functionality provided by git-submodule is not
    sufficient for this mode of operation. Most git commands, like checkout
    or commit, do not recursively descend into the submodules so you are
    forced to do execute all git commands N+1 times (leading to pain and
    mistakes), also, submodules revisions are tracked in the supermodule so
    that change to the slave project made outside the superproject are not
    automatically seen. Since git does not allow partial checkouts, we are
    left with little alternative.

    Thus, to solve these problems gits was born. Complexity pain is still
    involved, but the hope is that it is minimized compared to all of the
    other alternatives.

    The basic theory is that there are a few sub-commands (prepare, attach,
    populate) which help set up the meta-project for gits operations. Then,
    for any git command which is not file specific (git add <filename>; git
    reset <filename>; etc), you should use "gits" instead of "git", and the
    command will run on all repositories in the project.

  Example Usage
    In the following example, we will have the following master
    repositories:

      ssh://sourcemaster/src/repos/super.git
      ssh://sourcemaster/src/repos/lib1.git
      ssh://sourcemaster/src/repos/lib2.git

    The desired working layout of directories with .git in them on disk is:

      ..../super
      ..../super/lib1
      ..../super/lib2

   Initialize a gits project
    gits prepare

    You run this command in the git directory which will be your top level
    master repository (super here). Typically you would clone this top level
    master from some other location which has all of your git projects.

      --------------------------------------------------
      git clone ssh://sourcemaster/src/repos/super.git super
      cd super
      gits prepare
      --------------------------------------------------

   Add a slave repository to top level master
      gits attach <repository> <localpath>

    Clone the named git repository into the named local directory, and set
    it up for further gits operations.

    Typically <localpath> would be a path relative to the top level working
    directory, for example, a subdirectory in the top level.

    <repository> can also be relative (relative to the URL the top level
    master checkout was cloned from). It may also be an absolute URL. If the
    URL starts with ^, it will use only the method and hostname from the
    master's URL. Otherwise, it will be relative to the fully qualified
    path. We will show both in operation in the example.

     --------------------------------------------------
     gits attach ../lib1.git lib1
     gits attach ^/src/repos/lib2.git lib2
     --------------------------------------------------

   Check out any new slave modules which someone else might have added
      gits [--[no-]fromcheckout] populate

    Go through the list of configured slaves and check out (clone) any which
    have not already been retrieved.

    With --fromcheckout, assume that the remote repository is a gits
    checkout instead of in standard repository layout. With
    --no-fromcheckout, assume that the remote repository has the standard
    layout. If either option is given, sets the default repository layout,
    which is used when no explicit option is provided.

      --------------------------------------------------
      gits populate
      --------------------------------------------------

   Perform a pull operation for all tracked branches
      gits pulls <args>

    For each branch being tracked by the superproject, go through the list
    of configured slaves, check yourself out to the branch, perform a pull,
    then switch back to the branch you were on.

      --------------------------------------------------
      gits pulls --rebase
      --------------------------------------------------

   Show unified commit logs in a fixed output format
      gits logs <args>

    For each branch being tracked by the superproject, generate a list of
    the "log" messages as specified by the <args>, and output them in a
    fixed format, with related commits grouped together and ordered by time.
    Do *not* provide git log options that modify the output format, as they
    will break the ordering and grouping functionality; only arguments that
    control the selection of commits should be used.

    The related commit grouping will group together all commits (in any
    sub-project) within an 8-hour period that have the same author e-mail
    and commit message.

      --------------------------------------------------
      gits logs HEAD...Product-3.1.1
      --------------------------------------------------

   Perform an arbitrary command for all tracked branches
      gits exec <command> [args]

    For each slave being tracked by the superproject and the superproject
    itself, cd to the root of the project directory and execute the listed
    command.

      --------------------------------------------------
      gits exec gitk
      --------------------------------------------------

   Print out URLs for arbitrary repositories like those used by attach
      gits resolve [--[no-]fromcheckout] <repository> <local_relpath>

    Go through the same process that gits uses for resolving relative
    repository URLs into absolute URLs, for debugging and certain porting
    efforts.

    With --fromcheckout, resolve URLs as if the repository were a clone of
    another gits checkout. With --no-fromcheckout, resolve URLs as if it
    were not a clone of another gits checkout. By default it uses the saved
    repository layout from gits populate or update-remote-url; however gits
    resolve does not change the saved default even if --fromcheckout or
    --no-fromcheckout is given.

      --------------------------------------------------
      gits resolve ../otherpos otherpos
      --------------------------------------------------

   Update the URL a remote repository points at
      gits update-remote-url [--[no-]fromcheckout] <remote-name> <url>

    Update the super-project's remote.name.url using the url and remote name
    listed above. Then go though each slave repository and update its url
    using the normal relative url mechanism.

    The --fromcheckout option supports using a gits checkout as the remote
    repository, adjusting the repository paths from their default. The
    --no-fromcheckout option assumes a normal repository layout for the
    remote. If neither option is given, the saved repository layout from the
    most recent gits populate or update-remote-url command is used; however,
    this is not generally correct, as the repository layout of the new
    remote need not be the same as the old one. If either --fromcheckout or
    --no-fromcheckout is given, sets the default repository layout
    accordingly.

    You can use this command after a clone of a local repository (or local
    gits checkout, using gits populate --fromcheckout) so that the new
    repository uses the same remote origin as the first one. (The local
    clone/populate is much faster than performing a remote clone/populate.)

      --------------------------------------------------
      git clone /home/user/work/awb /home/user/work/newawb
      cd /home/user/work/newawb
      gits populate --fromcheckout
      gits update-remote-url --no-fromcheckout origin ssh://git/src/git/awb
      --------------------------------------------------

   Push a change to a remote repository
      gits push [--quick] [standard args]

    This is the standard git push command--with the addition of a --quick
    option which will only attempt to push for branches which have
    outstanding changes. For slow connections to large number of slave
    repositories, the overhead of an empty push can be large.

    However, --quick only checks to see if the CURRENT branch needs to push
    data. If you have changes on other branches, a slow push is still
    required, as it is if you are pushing to someplace other than your
    standard origin.

      --------------------------------------------------
      gits push --quick
      --------------------------------------------------

   Everything else
    All other commands are passed directly though to git, with one command
    being run per repository. Output summarizing is performed so that
    multiple repositories with the same git output will only have the git
    output shown once. `git status` has a more aggressive summarizing to
    merge the lists of files in each section.

      Examples:
      --------------------------------------------------
      gits commit -a -m "This is a change"
      gits push
      gits pull
      gits branch testing
      gits checkout testing
      gits diff master testing
      gits status
      gits ....
      --------------------------------------------------

    All normal git commands are supported (plus any potential future
    commands) but not all commands make sense to run with gits. One good
    example is git-daemon.

DESCRIPTION
  --no-master
    This flag requests that gits only run the listed command on the slave
    repositories and NOT the super/master/top repository. This probably will
    not be needed much.

  --exclude regexp
    Provide a regular expression which excludes those slaves from
    consideration from gits commands which it matches.

  --no-progress
    This flag requests that gits NOT print a progress bar, which it does by
    default for slow operations if Term::ProgressBar is loaded. Slow
    operations are defined as: checkout, pulls, push. You may use this flag
    for all operations.

  --parallel COUNT
    Specify the number of parallel git operations you wish to execute.
    Parallelism is only activated for "push" and "pulls" subcommands. This
    can speed up your processing significantly for large numbers of
    submodules.

    If remote repositories are accessed over ssh, you may also wish to
    activate ssh "ControlMaster" multiplexing.

      ssh_config
      --------------------------------------------------
      Host git
         ControlMaster auto
         ControlPath ~/.ssh/master-%r@%h:%p
      --------------------------------------------------

    However, there currently is a "auto" race condition so the first batch
    of peers do not necessarily take advantage of the multiplexing and there
    have occasionally been spurious errors with this enabled.

  --no-commit
    This flag requests that gits-internal sub-commands, such as prepare or
    attach should not commit their changes after they made them.

  --keep-going
    Do not abort when any subsidiary git command fails - instead print a
    warning and continue processing. Some git command failures will still be
    considered fatal and cause gits to abort.

  --verbose -v
    Ask for more information about what is happening. You may repeat the
    flag multiple times to get more information. Two levels of verbosity
    typically prints the underlying commands being executed and the data
    being returned from them.

  --quiet
    Ask for less information, which currently means discarding the STDERR of
    some of the administrative git commands which are executed.

  subcommand args...
    Run the specified git command (with associated arguments) on the
    repository and all slave repositories. Typically they are git commands
    run over each slave, but there are gits specific commands such as:
    pulls, prepare, attach, populate, resolve, exec, logs, and
    update-remote-url. See OVERVIEW for more information on specific
    subcommands.

BUGS
    gits changes directory to the directory where .gitslave exists.
    Likewise, when executing most git commands, gits changes directory to
    the root of the git slave, so any pathnames being passed in to gits must
    be absolute, not relative. Generally this is only a concern for
    pre-generate commit messages or something, you should NOT be passing
    files checked into git in a gits command--you will likely get the wrong
    result.

FILES
  .gitslave
    The file containing the list of slave repositories (possibly in relative
    form) and the directories relative to the master root where they should
    be checked out.

    The format of this file is:

    "possibly-relative-repository-path" "top-level-checkout-relative-path"[
    flags]

    The flags, which are optional, currently can be the value "ifpresent"
    which indicates that gits will only process those modules if the
    top-level-checkout-relative-path is already present.

ENVIRONMENT
  $GITSLAVE
    Allow overriding on the name of the .gitslave file (for supplemental
    activity, the .gitslave file must still exist even if it is not used for
    this particular operation). Also, allows a comma-space separated list of
    files names, the sum of which will be the list of slaves to use.

    An example ".gitslave, .gitslave-extras" would allow an supplemental
    list of slaves for unusual activity (e.g. release tagging) to the normal
    list.

    Alternately, you could play tricks where you only get a subset of the
    modules when you don't need to play with everything.

AUTHOR
    Seth Robertson

REPORTING BUGS
    Report bugs to <projectbaka@baka.org>

COPYRIGHT
    Copyright (c) 2008 Seth Robertson. License is similar to the GNU Lesser
    General Public License version 2.1, see LICENSE.TXT for more details.

SEE ALSO
    git(1)

