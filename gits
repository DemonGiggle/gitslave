#!/usr/bin/perl
#
# Support .gitslave files, recursive processing of git commands into slave directories
#
# ++Copyright LIBBK++
#
# Copyright (c) 2003 The Authors. All rights reserved.
#
# This source code is licensed to you under the terms of the file
# LICENSE.TXT in this release for further details.
#
# Mail <projectbaka@baka.org> for further information
#
# --Copyright LIBBK--
#
use strict;
use warnings;
no warnings 'uninitialized';
no warnings 'io';
use Cwd;
use File::Spec;
use constant GITSLAVE => '.gitslave';
use Getopt::Long;
use File::Path;


our($GITSLAVE) = $ENV{'GITSLAVE'}||GITSLAVE;
our($GITS_DIR);
our(@slaves);
my($USAGE) = "usage: gits [--version] [--no-master] [--no-commit] [--keep-going] [-v|--verbose]+ [--quiet] [--help] <subcommand> [args]...\n";
our(%OPTIONS);
my ($returncode) = 0;
delete($ENV{'GIT_DIR'});


######################################################################
#
# Translate wait status ($?) into human-readable terms
#
sub exitcode(;$)
{
  my ($ret) = @_;
  $ret = $? if !defined($ret);

  if ($ret & 127)
  {
    return "killed by signal " . ($ret & 127);
  }
  return "exit " . ($ret >> 8);
}

######################################################################
#
# Run a command where we don't care about the output
#
sub docmd($)
{
  my ($cmd) = @_;

  $cmd .= " 2>/dev/null" if ($OPTIONS{'quiet'});
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  system($cmd);
  print STDERR "Command " . exitcode() . "\n" if ($OPTIONS{'verbose'} > 1);
  $? == 0;
}



######################################################################
#
# Run a command, retrieving the output
#
sub getcmd($)
{
  my ($cmd) = @_;

  $cmd = "($cmd) 2>&1";
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  my $out = `$cmd`;
  if ($OPTIONS{'verbose'} > 1)
  {
    my $tout = $out;
    chomp($tout);
    print STDERR "Command " . exitcode() . "\n ($tout)\n";
  }

  wantarray?($?, $out):$out;
}



######################################################################
#
# Find the absolute path to repository (relatives are relative to local repository)
#
sub resolve_repository($)
{
  my ($repos) = @_;

  # Check for already absolute
  return $repos if ($repos =~ m-^(/|\w+:/)-);

  # Break into method and path sections
  my ($prefix, $suffix) = ("", $repos);
  ($prefix, $suffix) = ($1, $2) if ($repos =~ m-^(\w+:)(.*)-);

  # Find upstream origin URL
  my ($ret, $master_repo) = getcmd("git config remote.origin.url");
  chomp($master_repo);
  die "Could not find git upstream clone which this is relative to\n" unless ($ret == 0 && $master_repo);

  # Nuke trailing .git, if necessary
  $master_repo =~ s:/.git$::;
  my ($mprefix, $msuffix) = ("", $master_repo);
  ($mprefix, $msuffix) = ($1, $2) if ($repos =~ m-^(\w+:(?://[^/]*|))(.*)-);

  # Is this repository-relative? (keep method://host from master)
  if ($repos =~ m:^\^(/.*):)
  {
    return "$mprefix$1";
  }

  # Do we have a replacement method://?  (Seems like an unlikely case)
  if ($prefix)
  {
    $master_repo = $prefix.$msuffix;
  }

  # Handle smushing together, relative paths, etc
  $repos = "$master_repo/$suffix";
  while ($repos =~ s:/\./:/:) {;}
  while ($repos =~ s:/[^/]+?/\.\./:/:) {;}
  while ($repos =~ s-(^\w+://.*)//-$1-g) {;}
  while ($repos !~ m-^\w+://- && $repos =~ s://:/:g) {;}
  $repos;
}



######################################################################
#
# check whether command requires slave configuration
#
sub ephemeral_command($)
{
  my ($cmd) = @_;
  return ($cmd eq "prepare" or $cmd eq "resolve" or $cmd eq "help");
}



######################################################################
#
# Get list of currently configured slaves
#
sub git_slave_list($)
{
  my ($cmd) = @_;
  my (@gits);

  foreach my $slavefile (split(/, /,$GITSLAVE))
  {
    $slavefile = "$GITS_DIR/$slavefile";
    if (!open(R, "<", $slavefile))
    {
      die "Could not find $slavefile file\n"
	unless (!defined($cmd) or ephemeral_command($cmd));
      next;
    }
    my ($lineno) = 1;
    while (<R>)
    {
      next if (/^\s*(?:\#.*)$/);
      die "Bad line $lineno in $slavefile\n" unless (/^\"(.*)\" \"(.*)\"$/);
      push(@gits,[$1, $2]);
    }
    close(R);
  }
  @gits;
}



######################################################################
#
# Check for presence of slave
#
my ($warngitslavesync) = 0;

sub missing_slave($)
{
  my ($slave) = @_;
  if (!-d $slave)
  {
    warn "Missing one or more git slaves including $slave, consider 'gits populate'.\n" unless ($warngitslavesync);
    $warngitslavesync++;
    return 1;
  }
  return 0;
}



######################################################################
#
# Add shell quoting to avoid problems
#
sub quoteit(@)
{
  my $str;
  foreach my $item (@_)
  {
    my $qitem = $item;
    $qitem =~ s/([\\\"])/\\$1/;
   $str .= '"'.$qitem.'" ';
  }
  chop($str);
  $str;
}



######################################################################
#
# Populate - clone projects listed in .gitslaves
#
sub do_populate(;$)
{
  my ($nocheckout)=@_;
  my $curbranch;

  $nocheckout='-n' if ($nocheckout);

  foreach my $group (@slaves)
  {
    my $slave = $group->[1];

    if (! -d $slave)
    {
      print "gits: Cloning $slave\n" if ($OPTIONS{'verbose'});
      my ($repos) = resolve_repository($group->[0]);
      docmd(qq^git clone $nocheckout "$repos" "$slave"^) || die "Could not clone $repos onto $slave\n";

      $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0] unless ($curbranch);
      if ($curbranch ne "master" && $curbranch !~ /no branch/)
      {
	print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
	docmd(qq^cd "$slave"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist for $slave\n";
      }
    }
    else
    {
      print "gits: $slave already exists\n" if ($OPTIONS{'verbose'});
    }
  }
}



######################################################################
#
# git checkout, gits style
#
sub do_checkout($@)
{
  my ($pushprocessing,@args) = @_;
  my ($ret, $msg) = (0, undef);
  my ($slavecnt) = -1;
  my ($ok, $okcnt);
  my (%msg);
  my ($group, $slave) = (undef, ".");

  if (!$OPTIONS{'no-master'})
  {
    my ($cmd) = qq^cd $slave && git checkout ^.quoteit(@args);
    $cmd .= " >&/dev/null" if ($pushprocessing == 2);
    ($ret, $msg) = getcmd($cmd);

    if ($ret == 0)
    {
      # Reload list of slaves, which might have changed due to superproject checkout
      @slaves = git_slave_list("checkout");

      # New list of slaves might have stuff we need to check out
      do_populate(1);
    }
  }
  my ($totcnt) = $#slaves + $OPTIONS{'no-master'}?1:2;

  # Tricky: This backwards loop is designed so that the return code processing can be shared between superproject and slaves
  do
  {
    if ($ret != 0)
    {
      chomp($msg);
      my $warn = "gits checkout (@{[join(' ',@args)]}), failed for: '$slave': " . exitcode($ret);
      if ($OPTIONS{'keep-going'})
      {
	warn "Error in $warn (continuing)\n $msg\n";
      }
      else
      {
	my $diemsg = "Aborting $warn\n ";
	if ($ok)
	{
	  $diemsg .= "(ran fine on: $ok, did not run on @{[$totcnt-$okcnt]} other(s); no rollbacks)";
	}
	else
	{
	  $diemsg .= "(first entry, no other successfully executed)";
	}
	die "$diemsg\n  $msg\n";
      }
    }
    else
    {
      $ok .= " $slave";
      $okcnt++;
      if ($pushprocessing)
      {
	$msg =~ s/Switched to branch.*\n//;
	$msg =~ s/Already on \".*\n//;
	push(@{$msg{"$args[0]\@$slave"}}, $slave);
      }
      else
      {
	push(@{$msg{$msg}}, $slave);
      }
    }

    # Forward through the slave list
    if (++$slavecnt <= $#slaves)
    {
      $group = $slaves[$slavecnt];
      $slave = $group->[1];

      my ($cmd) = qq^cd $slave && git checkout ^.quoteit(@args);
      $cmd .= " >&/dev/null" if ($pushprocessing == 2);
      ($ret, $msg) = getcmd($cmd);
    }
  } while ($slavecnt <= $#slaves);

  %msg;
}




######################################################################
#
# Main functionality
#
Getopt::Long::Configure("bundling", "no_ignore_case", "no_auto_abbrev", "no_getopt_compat", "require_order");
GetOptions(\%OPTIONS, 'version', 'no-master', 'no-commit', 'keep-going', 'press-on', 'verbose|v+', 'quiet', 'help') || die $USAGE;

# provide baka terminology compatibility
my $BAKANAMES = { 'inits' => 'prepare', 'clones' => 'attach',
		  'checkouts' => 'populate', 'execs' => 'exec',
		  'resolves' => 'resolve' };
$ARGV[0] = $BAKANAMES->{$ARGV[0]} if $BAKANAMES->{$ARGV[0]};
$OPTIONS{'keep-going'} = 1 if $OPTIONS{'press-on'};

die "$USAGE" if ($#ARGV < 0 and !($OPTIONS{'version'} or $OPTIONS{'help'}));

# Find GITS_DIR -- location of git slave file
if ($ENV{'GITS_DIR'} && -f $ENV{'GITS_DIR'}."/".GITSLAVE)
{				# Use gitslave location user told us
  $GITS_DIR = $ENV{'GITS_DIR'};
}
else
{				# Probe for gitslave location
  $GITS_DIR = '.';
  my (@S,$dev,$ino) = stat($GITS_DIR);

  do
  {
    if (!-f $GITS_DIR."/".GITSLAVE)
    {
      $GITS_DIR .= '/..';
      $dev = $S[0];
      $ino = $S[1];
      @S = stat($GITS_DIR);
    }
  } while (!-f $GITS_DIR."/".GITSLAVE && $S[0] != $dev && $S[1] != $ino);
}

# All operations are relative to gitslave base
if (-f $GITS_DIR."/".GITSLAVE)
{
  $GITS_DIR = Cwd::realpath($GITS_DIR);
  chdir($GITS_DIR);
  print STDERR "gits: Gitslave found in $GITS_DIR\n" if ($OPTIONS{'verbose'} > 1);
}
else
{
  die "You must run 'gits prepare', could not find @{[GITSLAVE]}\n"
    unless ($#ARGV < 0 or ephemeral_command($ARGV[0]));
}

@slaves = git_slave_list($ARGV[0]);

if ($OPTIONS{'version'})
{
  my $version = "{UNTAGGED}";

  # <TRICKY> If the version string is still UNTAGGED, try to run the local
  # git commands to get the current hash and possibly tag; this is used by
  # Makefile to get the correct string to replace it with.  Otherwise, the
  # installation has replaced it with a version; don't mess with it.  Use
  # string concatenation to keep this check from getting replaced. </TRICKY>

  if ($version eq "{" . "UNTAGGED" . "}")
  {
    my ($ret,$hash) = getcmd("git log --pretty=format:%H -n 1");
    chomp($hash);

    my ($dret,$desc) = getcmd("git describe --tags $hash 2>/dev/null");
    if ($dret)
    {
      $desc = "Untagged ($hash)\n";
    }
    else
    {
      # strip out leading tag alphabetic and space, get just the numbers
      $desc =~ s/^[A-Za-z_ -]*([0-9][0-9._-]*[0-9]).*/$1/;
      $desc =~ y=/_=--=;
    }
    print $desc;
  }
  else
  {
    print "gits version $version\n";
    my ($vret,$vers) = getcmd("git --version");
    if ($vret || ($vers !~ /version ([2-9]|1\.[6-9])/))
    {
      print STDERR "git version >= 1.6 required!\n";
      $returncode = 1;
    }
    print $vers;
  }
}
elsif ($ARGV[0] eq 'help' or $OPTIONS{'help'})
{
  print "$USAGE";
  use FindBin qw($Bin $Script);
  docmd("pod2text < $Bin/$Script |" .
	"sed -n -e '/^DESCRIPTION/,/^BUGS/H'" .
	" -e '/^BUGS/{x;s/\\n[[:upper:]]*/\\n/g;s/\\n\\n/\\n/;p;}'");
  exit;
}
elsif ($ARGV[0] eq 'prepare')
{
  die "gits prepare takes no arguments\n" if ($#ARGV != 0);
  $GITS_DIR=$ENV{'GITS_DIR'} || ".";
  die "Refusing to prepare, \$GITSLAVE variable is multipath\n" if ($GITSLAVE =~ /, /);
  die "Refusing to prepare, $GITS_DIR/@{[$GITSLAVE]} already exists\n" if (-f $GITS_DIR."/".$GITSLAVE);
  open(W, ">", $GITS_DIR."/".$GITSLAVE) || die "Could not create $GITS_DIR/@{[$GITSLAVE]}\n";
  close(W);
  docmd("git add @{[$GITSLAVE]}");
  docmd(qq^git commit -m "gits creating @{[$GITSLAVE]}" @{[$GITSLAVE]}^) unless ($OPTIONS{'no-commit'});
}
elsif ($ARGV[0] eq 'attach')
{
  die "gits attach requires two arguments\nusage: gits attach <repository> <directory>\n" if ($#ARGV != 2 || !$ARGV[1] || !$ARGV[2]);
  my ($repos) = resolve_repository($ARGV[1]);
  die "Refusing to attach, \$GITSLAVE variable is multipath\n" if ($GITSLAVE =~ /, /);
  die "Destination ($ARGV[2]) already exists\n" if (-e $ARGV[2]);
  if ($ARGV[2] =~ m:(.*)/(.*):)
  {
    die "Destination ($ARGV[2]) cannot end in a slash" if (length($2) < 1);
    die "Destination parent ($1) does not exist\n" if (!-d $1);
  }
  my $files = $GITS_DIR."/".$GITSLAVE;
  docmd(qq^git clone "$repos" "$ARGV[2]"^ || die "Could not clone $repos onto $ARGV[2]\n");

  open(W, ">>", $files);
  print W qq^"$ARGV[1]" "$ARGV[2]"\n^;
  close(W);

  if ($ARGV[2] !~ m:/:)
  {
    my ($needadd) = 0;
    $needadd++ if (! -f "$GITS_DIR/.gitignore");
    open(W, ">>", $GITS_DIR."/.gitignore");
    print W qq^$ARGV[2]\n^;
    close(W);
    $files .= " .gitignore";
    docmd(qq^git add .gitignore^) if ($needadd);
  }
  docmd(qq^git commit -m 'gits adding "$ARGV[1]" "$ARGV[2]"' $files^) unless ($OPTIONS{'no-commit'});

  my $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
  if ($curbranch ne "master")
  {
    print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
    docmd(qq^cd "$ARGV[2]"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist\n";
  }
}
elsif ($ARGV[0] eq 'populate')
{
  die "gits populate takes no arguments\n" if ($#ARGV != 0);

  do_populate();
}
elsif ($ARGV[0] eq 'resolve')
{
  die "gits resolve requires at least one argument\n" if ($#ARGV < 1);

  shift(@ARGV);
  foreach my $repos (@ARGV)
  {
    print resolve_repository($repos)."\n";
  }
}
elsif ($ARGV[0] eq 'pulls')
{
  shift(@ARGV);
  my ($ok,$okcnt,%msg);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my $oldbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];

  foreach my $branch (grep(s/branch\.(.*)\.remote=.*/$1/,split(/\n/,getcmd(qq%git config -l%))))
  {
    my (%newmsg) = do_checkout(1, $branch);

    foreach my $group (@list)
    {
      my $slave = $group->[1];

      next if missing_slave($slave);

      my ($ret, $msg) = getcmd(qq^cd $slave && git pull ^.quoteit(@ARGV));
      if ($ret != 0)
      {
	chomp($msg);
	my $warn = "gits pulls, failed on branch $branch for: '$slave': " . exitcode($ret);
	if ($OPTIONS{'keep-going'})
	{
	  warn "Error in $warn (continuing)\n $msg\n";
	  next;
	}

	my $diemsg = "Aborting $warn\n ";
	if ($ok)
	{
	  $diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
	}
	else
	{
	  $diemsg .= "(first entry, no other successfully executed)";
	}
	die "$diemsg\n  $msg\n";
      }
      $msg =~ s/Switched to branch.*\n//;
      $msg =~ s/Already on \".*\n//;
      $ok .= " $slave";
      $okcnt++;
      $msg = $newmsg{$slave}.$msg;
      push(@{$msg{$msg}}, "$branch\@$slave");
    }
  }
  foreach my $group (@list)
  {
    my $slave = $group->[1];

    next unless (-d $slave);
    do_checkout(2, $oldbranch);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }

}
elsif ($ARGV[0] eq 'checkout')
{
  shift(@ARGV);
  my (%msg) = do_checkout(0, @ARGV);

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }

}
elsif ($ARGV[0] eq 'exec')
{
  shift(@ARGV);
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($branch);
  my (%group,%groupc,%msg);
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    next if missing_slave($slave);

    my ($ret, $msg) = getcmd(qq^cd $slave && ^.quoteit(@ARGV));
    if ($ret != 0)
    {
      chomp($msg);
      my $warn = "gits exec $ARGV[0], failed for: '$slave': " . exitcode($ret);

      if ($OPTIONS{'keep-going'})
      {
	warn "Error in $warn (continuing)\n $msg\n";
	next;
      }

      my $diemsg = "Aborting $warn\n ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg\n  $msg\n";
    }
    $ok .= " $slave";
    $okcnt++;

    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
elsif ($ARGV[0] eq 'update-remote-url')
{
  my ($cmd,$name,$url) = @ARGV;
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my (%msg);
  my ($warngitslavesync) = 0;

  die "gits update-remote-url requires two arguments\nusage: gits update-remote-url <remote-name> <new-super-url>\n" unless ($name && $url);

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    next if missing_slave($slave);

    my ($thisurl) = $url;
    if ($slave ne ".")
    {
      $thisurl = resolve_repository($group->[0]);
    }

    my ($ret, $msg) = getcmd(qq^cd $slave; git config "remote.$name.url" "$thisurl"^);
    if ($ret != 0)
    {
      chomp($msg);
      my $warn = "gits $cmd, failed for: '$slave': " . exitcode($ret);

      if ($OPTIONS{'keep-going'})
      {
	warn "Error in $warn\n $msg\n";
	next;
      }

      my $diemsg = "Aborting $warn\n ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg\n  $msg\n";
    }
    $ok .= " $slave";
    $okcnt++;

    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
elsif ($ARGV[0] eq 'status')
{
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($branch);
  my (%group,%groupc,%msg);
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    next if missing_slave($slave);

    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 && $ret != 256)
    {
      chomp($msg);
      my $warn = "gits $ARGV[0], failed for: '$slave': " . exitcode($ret);

      if ($OPTIONS{'keep-going'})
      {
	warn "Error in $warn\n $msg\n";
	next;
      }

      my $diemsg = "Aborting $warn\n ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg\n  $msg\n";
    }
    elsif ($ret == 256)
    {
      # git status seems to return 1 (nee wait 256) under all circumstances, so do
      # not even propagate this condition.
      #$returncode = 1;
      1;
    }
    $ok .= " $slave";
    $okcnt++;

    my ($premove);
    while ($msg =~ s/(^[^\#].*\n)//)
    {
      $premove .= $1;
    }

    die "gits unexpected status output (missing branch): $msg" unless ($msg =~ s/^\# On branch (.*)\n//);
    $branch = $1 unless ($branch);
    die "Branch ($branch != $1) not identical between @{[$list[0]->[1]]} and $slave\n" unless ($branch eq $1);

    if ($msg =~ s/^\# (Your branch is .*\n)//)
    {
      $premove .= $1;
      $msg =~ s/^\#\s*\n//;
    }

    while ($msg =~ s/^(\# \S.*\n)//)
    {
      my ($group) = $1;
      while ($msg =~ s/^(\#\s{2,}\S.*\n)//)
      {
	$groupc{$group}->{$1} = 1;
      }
      die "Could not parse git status output for $slave <$group> <$msg>\n" unless ($msg =~ s/^(\#\s*\n)//);

      while ($msg =~ s/^(\#(?:\s*|(\s{2,}|\t)\S.*)\n)//)
      {
	my ($line) = $1;

	if ($line =~ /([^:]+:\s+)(.*)/s)
	{
	  $line = "$1$slave/$2";
	}
	elsif ($line =~ /(\#\s+)(.+)/)
	{
	  $line = "$1$2 (cd $slave)\n";
	}
	else
	{
	  next if ($line =~ /\#\s*\n/);
	}

	$group{$group} .= $line;
      }
    }

    push(@{$msg{$premove.$msg}}, $slave);
  }

  print "# On branch $branch\n";
  foreach my $group (sort keys %group)
  {
    print $group;
    foreach my $msg (sort keys %{$groupc{$group}})
    {
      print $msg;
    }
    print "#\n";
    print $group{$group};
    print "#\n";
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
elsif ($ARGV[0] eq 'clean')
{
  shift(@ARGV);
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my (@unlinkers);
  my (%msg);
  my ($warngitslavesync) = 0;
  my ($commonout);

  my $CLEAN_USAGE = "usage: gits clean -f|-n [-dqxX] [--] [path]...\n";
  my %COPTIONS;
  GetOptions(\%COPTIONS, 'd', 'f', 'q', 'n', 'X', 'x') || die $CLEAN_USAGE;

  die "Must set exactly one of -n or -f\n$CLEAN_USAGE" unless (!$COPTIONS{'f'} != !$COPTIONS{'n'});

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits populate.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($cmd) = qq^cd $slave && git clean -n^;
    $cmd .= " -d" if ($COPTIONS{'d'});
    $cmd .= " -f" if ($COPTIONS{'f'});
    $cmd .= " -X" if ($COPTIONS{'X'});
    $cmd .= " -x" if ($COPTIONS{'x'});
    $cmd .= " -- ".quoteit(@ARGV) if ($#ARGV >= 0);

    my ($ret, $msg) = getcmd($cmd);
    if ($ret != 0)
    {
      chomp($msg);
      my $warn = "gits $ARGV[0], failed for: '$slave': " . exitcode($ret);

      if ($OPTIONS{'keep-going'})
      {
	warn "Error in $warn\n $msg\n";
	next;
      }

      my $diemsg = "Aborting $warn\n ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg\n  $msg\n";
    }
    $ok .= " $slave";
    $okcnt++;

    my $newmsg;
    foreach my $line (split(/\n/,$msg))
    {
      if ($line =~ s/(Would( not)? remove )(.*)//)
      {
	my ($pre,$not,$path) = ($1,$2,$3);

	# Canonicalize
	$path = "$slave/$path";
	$path =~ s:^./::;

	# Check directory to see if it matches slavedir
	if ($path =~ s:/$::)
	{
	  my ($qpath) = quotemeta($path);

	  next if grep($_->[1] =~ m:^$qpath$:, @slaves);

	  # Restore trailing /
	  $path .= "/";
	}
	if ($COPTIONS{'n'})
	{
	  $commonout .= $pre.$path."\n";
	  next;
	}
	next if ($not);
	$commonout .= "Removing $path\n";
	push(@unlinkers,$path);
      }
      else
      {
	$newmsg .= $_;
      }
    }

    push(@{$msg{$newmsg}}, $slave);
  }

  print $commonout unless ($COPTIONS{'q'});

  if (!$COPTIONS{'n'} && $#unlinkers >= 0)
  {
    rmtree(\@unlinkers, $OPTIONS{'verbose'}) || die "Cannot unlink";
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    next if ($msg eq "" && $COPTIONS{'q'});
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
else
{
  my ($ok,$okcnt);
  my %msg;

  # This is a sign that you are doing something wrong
  if (-f $ARGV[$#ARGV])
  {
    warn "You have a pathname in a generic gits command, this is a sign that the command\nwill not work since it is unlikely to exist in all modules\nProbably you want to cd to the submodule and run a raw git command\n";
  }

  # Run the command for each module
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    next if missing_slave($slave);

    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 &&
	!($ARGV[0] eq "commit" && $msg =~ /nothing to commit/))
    {
      chomp($msg);
      my $warn = "gits $ARGV[0], failed for: '$slave': " . exitcode($ret);

      if ($OPTIONS{'keep-going'})
      {
	warn "Error in $warn\n $msg\n";
	next;
      }

      my $diemsg = "Aborting $warn\n ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg\n  $msg\n";
    }
    $ok .= " $slave";
    $okcnt++;
    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
exit($returncode);



=pod

=head1 NAME

gits - The git slave repository tool

=head1 SYNOPSIS

gits [--version] [--no-master] [--no-commit] [--keep-going] [-v|--verbose]+ [--quiet] [--help] <subcommand> [args]...

=head1 OVERVIEW

gits is a program which assists in assembling a meta-project from a
number of individual git repositories which you own and operate as if
it were one git repository instead of many, similar to how CVS works
by default and svn (v1.5) can be coerced to work.  Some of these
individual git repositories may be part of other meta-projects as
well.

Unfortunately, the functionality provided by git-submodule is not
sufficient for this mode of operation.  Most git commands, like
checkout or commit, do not recursively descend into the submodules so
you are forced to do execute all git commands N+1 times (leading to
pain and mistakes), also, submodules revisions are tracked in the
supermodule so that change to the slave project made outside the
superproject are not automatically seen.  Since git does not allow
partial checkouts, we are left with little alternative.

Thus, to solve these problems gits was born.  Complexity pain is still
involved, but the hope is that it is minimized compared to all of the
other alternatives.

The basic theory is that there are a few sub-commands (prepare, attach,
populate) which help set up the meta-project for gits operations.
Then, for any git command which is not file specific (git add
<filename>; git reset <filename>; etc), you should use "gits" instead
of "git", and the command will run on all repositories in the project.

=head2 Example Usage

In the following example, we will have the following master
repositories:

  ssh://sourcemaster/src/repos/super.git
  ssh://sourcemaster/src/repos/lib1.git
  ssh://sourcemaster/src/repos/lib2.git


The desired working layout of directories with .git in them on disk
is:

  ..../super
  ..../super/lib1
  ..../super/lib2


=head3 Initialize a gits project

gits init

You run this command in the git directory which will be your top level
master repository (super here).  Typically you would clone this top
level master from some other location which has all of your git
projects.

  --------------------------------------------------
  git clone ssh://sourcemaster/src/repos/super.git super
  cd super
  gits prepare
  --------------------------------------------------



=head3 Add a slave repository to top level master

  gits attach <repository> <localpath>

Clone the named git repository into the named local directory, and set
it up for further gits operations.

Typically <localpath> would be a path relative to the top level
working directory, for example, a subdirectory in the top level.

<repository> can also be relative (relative to the URL the top level
master checkout was cloned from).  It may also be an absolute URL.  If
the URL starts with ^, it will use only the method and hostname from
the master's URL.  Otherwise, it will be relative to the fully
qualified path.  We will show both in operation in the example.

 --------------------------------------------------
 gits attach ../lib1.git lib1
 gits attach ^/src/repos/lib2.git lib2
 --------------------------------------------------


=head3 Check out any new slave modules which someone else might have added

  gits populate

Go through the list of configured slaves and check out (clone) any which have
not already been retrieved.

  --------------------------------------------------
  gits populate
  --------------------------------------------------


=head3 Perform a pull operation for all tracked branches

  gits pulls <args>

For each branch being tracked by the superproject, go through the list
of configured slaves, check yourself out to the branch, perform a pull,
then switch back to the branch you were on.

  --------------------------------------------------
  gits pulls --rebase
  --------------------------------------------------



=head3 Perform an arbitrary command for all tracked branches

  gits exec <command> [args]

For each slave being tracked by the superproject and the superproject itself,
cd to the root of the project directory and execute the listed command.

  --------------------------------------------------
  gits exec gitk
  --------------------------------------------------



=head3 Print out URLs for arbitrary repositories like those used by attach

  gits resolve <repository>...

Go through the same process that gits uses for resolving relative
repository URLs into absolute URLs, for debugging and certain porting
efforts.

  --------------------------------------------------
  gits resolve ../otherpos
  --------------------------------------------------



=head3 Update the URL a remote repository points at

  gits update-remote-url <remote-name> <url>

Update the super-project's remote.name.url using the url and remote
name listed above.  Then go though each slave repository and update
its url using the normal relative url mechanism.

Very useful when making another copy of a local repository mirroring a
remote repository which you wish to have the copy also point to the
remote repository.

  --------------------------------------------------
  gits update-remote-url origin ssh://git/src/git
  --------------------------------------------------



=head3 Everything else

All other commands are passed directly though to git, with one command
being run per repository.  Output summarizing is performed so that
multiple repositories with the same git output will only have the git
output shown once.  `git status` has a more aggressive summarizing
to merge the lists of files in each section.

  Examples:
  --------------------------------------------------
  gits commit -a -m "This is a change"
  gits push
  gits pull
  gits branch testing
  gits checkout testing
  gits diff master testing
  gits status
  gits ....
  --------------------------------------------------

All normal git commands are supported (plus any potential future
commands) but not all commands make sense to run with gits.  One good
example is git-daemon.

=head1 DESCRIPTION

=head2 --no-master

This flag requests that gits only run the listed command on the slave
repositories and NOT the super/master/top repository.  This probably
will not be needed much.

=head2 --no-commit

This flag requests that gits-internal sub-commands, such as prepare or
attach should not commit their changes after they made them.

=head2 --keep-going

Do not abort when a subsidiary git command fails for most commands,
instead print a warning and continue processing.

=head2 --verbose -v

Ask for more information about what is happening.  You may repeat the
flag multiple times to get more information.  Two levels of verbosity
typically prints the underlying commands being executed and the data
being returned from them.

=head2 --quiet

Ask for less information, which currently means discarding the STDERR
of some of the administrative git commands which are executed.

=head2 subcommand args...

Run the specified git command (with associated arguments) on the
repository and all slave repositories.  Typically they are git
commands run over each slave, but there are gits specific commands
such as: prepare, attach, populate, resolve, exec, and
update-remote-url.  See OVERVIEW for more information on specific
subcommands.

=head1 BUGS

gits changes directory to the directory where .gitslave exists.
Likewise, when executing most git commands, gits changes directory to
the root of the git slave, so any pathnames being passed in to gits
must be absolute, not relative.  Generally this is only a concern for
pre-generate commit messages or something, you should NOT be passing
files checked into git in a gits command--you will likely get the
wrong result.

=head1 FILES

=head2 .gitslave

The file containing the list of slave repositories (possibly in
relative form) and the directories relative to the master root where
they should be checked out.

=head1 ENVIRONMENT

=head2 $GITSLAVE

Allow overriding on the name of the .gitslave file (for supplemental
activity, the .gitslave file must still exist even if it is not used
for this particular operation).  Also, allows a comma-space separated
list of files names, the sum of which will be the list of slaves to
use.

An example ".gitslave, .gitslave-extras" would allow an supplemental
list of slaves for unusual activity (e.g. release tagging) to the
normal list.

Alternately, you could play tricks where you only get a subset of the
modules when you don't need to play with everything.

=head1 AUTHOR

Seth Robertson

=head1 REPORTING BUGS

Report bugs to <projectbaka@baka.org>

=head1 COPYRIGHT

Copyright (c) 2008 Seth Robertson.  License is similar to the GNU
Lesser General Public License version 2.1, see LICENSE.TXT for more
details.

=head1 SEE ALSO

git(1)
