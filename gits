#!/usr/bin/perl
#
# Support .gitslave files, recursive processing of git commands into slave directories
#
# ++Copyright LIBBK++
#
# Copyright (c) 2003 The Authors. All rights reserved.
#
# This source code is licensed to you under the terms of the file
# LICENSE.TXT in this release for further details.
#
# Mail <projectbaka@baka.org> for further information
#
# --Copyright LIBBK--
#
use strict;
use warnings;
no warnings 'uninitialized';
use Cwd;
use File::Spec;
use constant GITSLAVE => '.gitslave';
use Getopt::Long;



our($GITS_DIR);
my($USAGE) = "Usage: $0: [--no-master] [--no-commit] [--verbose]+ [-v]+ [--quiet] <command|help> [args]...\n";
our(%OPTIONS);
my ($returncode) = 0;
delete($ENV{'GIT_DIR'});


######################################################################
#
# Run a command where we don't care about the output
#
sub docmd($)
{
  my ($cmd) = @_;

  $cmd .= " 2>/dev/null" if ($OPTIONS{'quiet'});
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  system($cmd);
  print STDERR "Command returned: $?\n" if ($OPTIONS{'verbose'} > 1);
  $? == 0;
}



######################################################################
#
# Run a command, retrieving the output
#
sub getcmd($)
{
  my ($cmd) = @_;

  $cmd = "($cmd) 2>&1";
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  my $out = `$cmd`;
  print STDERR "Command returned: ($?, $out)\n" if ($OPTIONS{'verbose'} > 1);

  wantarray?($?, $out):$out;
}



######################################################################
#
# Find the absolute path to repository (relatives are relative to local repository)
#
sub resolve_repository($)
{
  my ($repos) = @_;

  # Check for already absolute
  return $repos if ($repos =~ m-^(/|\w+:/)-);

  # Break into method and path sections
  my ($prefix, $suffix) = ("", $repos);
  ($prefix, $suffix) = ($1, $2) if ($repos =~ m-^(\w+:)(.*)-);

  # Find upstream origin URL
  my ($ret, $master_repo) = getcmd("git config remote.origin.url");
  chomp($master_repo);
  die "Could not find git upstream clone which this is relative to\n" unless ($ret == 0 && $master_repo);

  # Nuke trailing .git, if necessary
  $master_repo =~ s:/.git$::;
  my ($mprefix, $msuffix) = ("", $master_repo);
  ($mprefix, $msuffix) = ($1, $2) if ($repos =~ m-^(\w+:(?://[^/]*|))(.*)-);

  # Is this repository-relative? (keep method://host from master)
  if ($repos =~ m:^\^(/.*):)
  {
    return "$mprefix$1";
  }

  # Do we have a replacement method://?  (Seems like an unlikely case)
  if ($prefix)
  {
    $master_repo = $prefix.$msuffix;
  }

  # Handle smushing together, relative paths, etc
  $repos = "$master_repo/$suffix";
  while ($repos =~ s:/./:/:) {;}
  while ($repos =~ s:/[^/]+?/../:/:) {;}
  while ($repos =~ s-(^\w+://.*)//-$1-g) {;}
  while ($repos !~ m-^\w+://- && $repos =~ s://:/:g) {;}
  $repos;
}



######################################################################
#
# Get list of currently configured slaves
#
sub git_slave_list()
{
  my (@gits);
  open(R, "<", "$GITS_DIR/@{[GITSLAVE]}") || return undef;
  my ($lineno) = 1;
  while (<R>)
  {
    next if (/^\s*(?:\#.*)$/);
    die "Bad line $lineno in $GITS_DIR/@{[GITSLAVE]}\n" unless (/^\"(.*)\" \"(.*)\"$/);
    push(@gits,[$1, $2]);
  }
  close(R);
  @gits;
}



######################################################################
#
# Add shell quoting to avoid problems
#
sub quoteit(@)
{
  my $str;
  foreach my $item (@_)
  {
    $str .= quotemeta($item).' ';
  }
  chop($str);
  $str;
}


######################################################################
#
# Main functionality
#
Getopt::Long::Configure("bundling", "no_ignore_case", "no_auto_abbrev", "no_getopt_compat", "require_order");
GetOptions(\%OPTIONS, 'verbose|v+', 'quiet', 'no-commit', 'no-master') || die $USAGE;

die "$USAGE" if ( $#ARGV < 0);

# Find GITS_DIR -- location of git slave file
if ($ENV{'GITS_DIR'} && -f $ENV{'GITS_DIR'}."/".GITSLAVE)
{				# Use gitslave location user told us
  $GITS_DIR = $ENV{'GITS_DIR'};
}
else
{				# Probe for gitslave location
  $GITS_DIR = '.';
  my (@S,$dev,$ino) = stat($GITS_DIR);

  do
  {
    if (!-f $GITS_DIR."/".GITSLAVE)
    {
      $GITS_DIR .= '/..';
      $dev = $S[0];
      $ino = $S[1];
      @S = stat($GITS_DIR);
    }
  } while (!-f $GITS_DIR."/".GITSLAVE && $S[0] != $dev && $S[1] != $ino);

}

# All operations are relative to gitslave base
if (-f $GITS_DIR."/".GITSLAVE)
{
  $GITS_DIR = Cwd::realpath($GITS_DIR);
  chdir($GITS_DIR);
  print STDERR "gits: Gitslave found in $GITS_DIR\n" if ($OPTIONS{'verbose'} > 1);
}
else
{
  die "Could not find @{[GITSLAVE]} file\n" unless ($ARGV[0] eq "inits");
}

my (@slaves) = git_slave_list();

if ($ARGV[0] eq 'help')
{
  print STDERR <<"EOF;";
gits - Support git operations into slave sub-repositories.  Kinda like
       gitmodules except recursive.

Commands:

help	    This message

inits	    Prepare a new @{[GITSLAVE]} file in the local directory.

clones <repository> <directory>
	    Specify a new slave repository to clone.
	    Repositories may include relative (relative to the clone
	    path of the local git repository) or ablsolute paths.

checkouts   Find all new slave repositories in the @{[GITSLAVE]} file
	    and check them out to disk.

<git command> [arguments]
	    Run the indicated git command, once per slave and once for
	    the master.  Abort on the first error.  Summarize output.

EOF;
}
elsif ($ARGV[0] eq 'inits')
{
  die "Inits requires no arguments\n" if ($#ARGV != 0);
  $GITS_DIR=$ENV{'GITS_DIR'} || ".";
  die "Refusing to init, $GITS_DIR/@{[GITSLAVE]} already exists\n" if (-f $GITS_DIR."/".GITSLAVE);
  open(W, ">", $GITS_DIR."/".GITSLAVE) || die "Could not create $GITS_DIR/@{[GITSLAVE]}\n";
  close(W);
  docmd("git add @{[GITSLAVE]}");
  docmd(qq^git commit -m "gits creating @{[GITSLAVE]}" @{[GITSLAVE]}^) unless ($OPTIONS{'no-commit'});
}
elsif ($ARGV[0] eq 'clones')
{
  die "Clone requires two arguments\n" if ($#ARGV != 2 || !$ARGV[1] || !$ARGV[2]);
  my ($repos) = resolve_repository($ARGV[1]);
  die "Destination already exists\n" if (-e $ARGV[2]);
  if ($ARGV[2] =~ m:(.*)/(.*):)
  {
    die "Destination ($ARGV[2]) cannot end in a slash" if (length($2) < 1);
    die "Destination parent ($1) does not exist\n" if (!-d $1);
  }
  my $files = $GITS_DIR."/".GITSLAVE;
  docmd(qq^git clone "$repos" "$ARGV[2]"^ || die "Could not clone $repos onto $ARGV[2]\n");

  open(W, ">>", $files);
  print W qq^"$ARGV[1]" "$ARGV[2]"\n^;
  close(W);

  if ($ARGV[2] !~ m:/:)
  {
    my ($needadd) = 0;
    $needadd++ if (! -f "$GITS_DIR/.gitignore");
    open(W, ">>", $GITS_DIR."/.gitignore");
    print W qq^$ARGV[2]\n^;
    close(W);
    $files .= " .gitignore";
    docmd(qq^git add .gitignore^) if ($needadd);
  }
  docmd(qq^git commit -m 'gits adding "$ARGV[1]" "$ARGV[2]"' $files^) unless ($OPTIONS{'no-commit'});

  my $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
  if ($curbranch ne "master")
  {
    print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
    docmd(qq^cd "$ARGV[2]"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist\n";
  }
}
elsif ($ARGV[0] eq 'checkouts')
{
  die "Checkouts requires no arguments\n" if ($#ARGV != 0);

  foreach my $group (@slaves)
  {
    if (! -d $group->[1])
    {
      print "gits: Checking out $group->[1]\n" if ($OPTIONS{'verbose'});
      my ($repos) = resolve_repository($group->[0]);
      docmd(qq^git clone "$repos" "@{[$group->[1]]}"^) || die "Could not clone $repos onto @{[$group->[1]]}\n";

      my $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
      if ($curbranch ne "master")
      {
	print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
	docmd(qq^cd "$group->[1]"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist\n";
      }
    }
    else
    {
      print "gits: $group->[1] already exists\n" if ($OPTIONS{'verbose'});
    }
  }
}
elsif ($ARGV[0] eq 'status')
{
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($branch);
  my (%group,%groupc,%msg);

  foreach my $group (@list)
  {
    my $slave = $group->[1];
    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 && $ret != 256)
    {
      my $diemsg = "Aborting gits $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    elsif ($ret == 256)
    {
      $returncode = 1;
    }
    $ok .= " $slave";
    $okcnt++;

    my ($premove);
    while ($msg =~ s/(^[^\#].*\n)//)
    {
      $premove .= $1;
    }

    die "gits unexpected status output (missing branch): $msg" unless ($msg =~ s/^\# On branch (.*)\n//);
    $branch = $1 unless ($branch);
    die "Branch ($branch != $1) not identical between @{[$list[0]->[1]]} and $slave\n" unless ($branch eq $1);

    while ($msg =~ s/^(\# \S.*\n)//)
    {
      my ($group) = $1;
      while ($msg =~ s/^(\#\s{2,}\S.*\n)//)
      {
	$groupc{$group}->{$1} = 1;
      }
      die "Could not parse git status output for $slave <$group> <$msg>\n" unless ($msg =~ s/^(\#\s*\n)//);

      while ($msg =~ s/^(\#(?:\s*|(\s{2,}|\t)\S.*)\n)//)
      {
	my ($line) = $1;

	if ($line =~ /([^:]+:\s+)(.*)/s)
	{
	  $line = "$1$slave/$2";
	}
	elsif ($line =~ /(\#\s+)(.+)/)
	{
	  $line = "$1$2 (cd $slave)\n";
	}
	else
	{
	  next if ($line =~ /\#\s*\n/);
	}

	$group{$group} .= $line;
      }
    }

    push(@{$msg{$premove.$msg}}, $slave);
  }

  print "# On branch $branch\n";
  foreach my $group (sort keys %group)
  {
    print $group;
    foreach my $msg (sort keys %{$groupc{$group}})
    {
      print $msg;
    }
    print "#\n";
    print $group{$group};
    print "#\n";
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
else
{
  my ($ok,$okcnt);
  my %msg;

  # This is a sign that you are doing something wrong
  if (-f $ARGV[$#ARGV])
  {
    warn "You have a pathname in a generic gits command, this is a sign that the command\nwill not work since it is unlikely to exist in all modules\nProbably you want to cd to the submodule and run a raw git command\n";
  }

  # Run the command for each module
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  foreach my $group (@list)
  {
    my $slave = $group->[1];
    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 &&
	!($ARGV[0] eq "commit" && $msg =~ /nothing to commit/))
    {
      my $diemsg = "Aborting gits $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    $ok .= " $slave";
    $okcnt++;
    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
