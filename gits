#!/usr/bin/perl
#
# Support .gitslave files, recursive processing of git commands into slave directories
#
# ++Copyright LIBBK++
#
# Copyright (c) 2003 The Authors. All rights reserved.
#
# This source code is licensed to you under the terms of the file
# LICENSE.TXT in this release for further details.
#
# Mail <projectbaka@baka.org> for further information
#
# --Copyright LIBBK--
#
use strict;
use warnings;
no warnings 'uninitialized';
no warnings 'io';
use Cwd;
use File::Spec;
use constant GITSLAVE => '.gitslave';
use Getopt::Long;


our($GITSLAVE) = $ENV{'GITSLAVE'}||GITSLAVE;
our($GITS_DIR);
my($USAGE) = "usage: gits [--version] [--no-master] [--no-commit] [--press-on] [-v|--verbose]+ [--quiet] [--help] <subcommand> [args]...\n";
our(%OPTIONS);
my ($returncode) = 0;
delete($ENV{'GIT_DIR'});


######################################################################
#
# Run a command where we don't care about the output
#
sub docmd($)
{
  my ($cmd) = @_;

  $cmd .= " 2>/dev/null" if ($OPTIONS{'quiet'});
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  system($cmd);
  print STDERR "Command returned: $?\n" if ($OPTIONS{'verbose'} > 1);
  $? == 0;
}



######################################################################
#
# Run a command, retrieving the output
#
sub getcmd($)
{
  my ($cmd) = @_;

  $cmd = "($cmd) 2>&1";
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  my $out = `$cmd`;
  if ($OPTIONS{'verbose'} > 1)
  {
    my $tout = $out;
    chomp($tout);
    print STDERR "Command returned: ($?, $tout)\n";
  }

  wantarray?($?, $out):$out;
}



######################################################################
#
# Find the absolute path to repository (relatives are relative to local repository)
#
sub resolve_repository($)
{
  my ($repos) = @_;

  # Check for already absolute
  return $repos if ($repos =~ m-^(/|\w+:/)-);

  # Break into method and path sections
  my ($prefix, $suffix) = ("", $repos);
  ($prefix, $suffix) = ($1, $2) if ($repos =~ m-^(\w+:)(.*)-);

  # Find upstream origin URL
  my ($ret, $master_repo) = getcmd("git config remote.origin.url");
  chomp($master_repo);
  die "Could not find git upstream clone which this is relative to\n" unless ($ret == 0 && $master_repo);

  # Nuke trailing .git, if necessary
  $master_repo =~ s:/.git$::;
  my ($mprefix, $msuffix) = ("", $master_repo);
  ($mprefix, $msuffix) = ($1, $2) if ($repos =~ m-^(\w+:(?://[^/]*|))(.*)-);

  # Is this repository-relative? (keep method://host from master)
  if ($repos =~ m:^\^(/.*):)
  {
    return "$mprefix$1";
  }

  # Do we have a replacement method://?  (Seems like an unlikely case)
  if ($prefix)
  {
    $master_repo = $prefix.$msuffix;
  }

  # Handle smushing together, relative paths, etc
  $repos = "$master_repo/$suffix";
  while ($repos =~ s:/\./:/:) {;}
  while ($repos =~ s:/[^/]+?/\.\./:/:) {;}
  while ($repos =~ s-(^\w+://.*)//-$1-g) {;}
  while ($repos !~ m-^\w+://- && $repos =~ s://:/:g) {;}
  $repos;
}



######################################################################
#
# Get list of currently configured slaves
#
sub git_slave_list($)
{
  my ($cmd) = @_;
  my (@gits);

  foreach my $slavefile (split(/, /,$GITSLAVE))
  {
    $slavefile = "$GITS_DIR/$slavefile";
    if (!open(R, "<", $slavefile))
    {
      die "Could not find $slavefile file\n"
	unless (!defined($cmd) or $cmd eq "inits" or $cmd eq "help");
      next;
    }
    my ($lineno) = 1;
    while (<R>)
    {
      next if (/^\s*(?:\#.*)$/);
      die "Bad line $lineno in $slavefile\n" unless (/^\"(.*)\" \"(.*)\"$/);
      push(@gits,[$1, $2]);
    }
    close(R);
  }
  @gits;
}



######################################################################
#
# Add shell quoting to avoid problems
#
sub quoteit(@)
{
  my $str;
  foreach my $item (@_)
  {
    my $qitem = $item;
    $qitem =~ s/([\\\"])/\\$1/;
   $str .= '"'.$qitem.'" ';
  }
  chop($str);
  $str;
}


######################################################################
#
# Main functionality
#
Getopt::Long::Configure("bundling", "no_ignore_case", "no_auto_abbrev", "no_getopt_compat", "require_order");
GetOptions(\%OPTIONS, 'version', 'no-master', 'no-commit', 'press-on', 'verbose|v+', 'quiet', 'help') || die $USAGE;

die "$USAGE" if ($#ARGV < 0 and !($OPTIONS{'version'} or $OPTIONS{'help'}));

# Find GITS_DIR -- location of git slave file
if ($ENV{'GITS_DIR'} && -f $ENV{'GITS_DIR'}."/".GITSLAVE)
{				# Use gitslave location user told us
  $GITS_DIR = $ENV{'GITS_DIR'};
}
else
{				# Probe for gitslave location
  $GITS_DIR = '.';
  my (@S,$dev,$ino) = stat($GITS_DIR);

  do
  {
    if (!-f $GITS_DIR."/".GITSLAVE)
    {
      $GITS_DIR .= '/..';
      $dev = $S[0];
      $ino = $S[1];
      @S = stat($GITS_DIR);
    }
  } while (!-f $GITS_DIR."/".GITSLAVE && $S[0] != $dev && $S[1] != $ino);
}

my (@slaves) = git_slave_list($ARGV[0]);

if ($OPTIONS{'version'})
{
  print "gits version UNTAGGED\n";
  docmd("git --version");
  exit($returncode);
}
elsif ($ARGV[0] eq 'help' or $OPTIONS{'help'})
{
  print <<"EOF;";
$USAGE
gits - Support git operations into slave sub-repositories.  Kinda like
       gitmodules except recursive.

Commands:

help	    This message.

inits	    Prepare a new @{[GITSLAVE]} file in the local directory.

clones <repository> <directory>
	    Specify a new slave repository to clone.
	    Repositories may include relative (relative to the clone
	    path of the local git repository) or ablsolute paths.

checkouts   Find all new slave repositories in the @{[GITSLAVE]} file
	    and check them out to disk.

pulls <args>
	    Run a `git pull <args>` for all local tracking branches to
	    bring them up to date

<git command> [arguments]
	    Run the indicated git command, once per slave and once for
	    the master.  Abort on the first error.  Summarize output.

For help with git commands, run `git help` or `git help COMMAND`.

EOF;
  exit;
}
elsif ($ARGV[0] eq 'inits')
{
  die "Inits requires no arguments\n" if ($#ARGV != 0);
  $GITS_DIR=$ENV{'GITS_DIR'} || ".";
  die "Refusing to init, \$GITSLAVE variable is multipath\n" if ($GITSLAVE =~ /, /);
  die "Refusing to init, $GITS_DIR/@{[$GITSLAVE]} already exists\n" if (-f $GITS_DIR."/".$GITSLAVE);
  open(W, ">", $GITS_DIR."/".$GITSLAVE) || die "Could not create $GITS_DIR/@{[$GITSLAVE]}\n";
  close(W);
  docmd("git add @{[$GITSLAVE]}");
  docmd(qq^git commit -m "gits creating @{[$GITSLAVE]}" @{[$GITSLAVE]}^) unless ($OPTIONS{'no-commit'});
  exit($returncode);
}
elsif ($ARGV[0] eq 'clones')
{
  die "Clone requires two arguments <repository> <directory>\n" if ($#ARGV != 2 || !$ARGV[1] || !$ARGV[2]);
  my ($repos) = resolve_repository($ARGV[1]);
  die "Refusing to clones, \$GITSLAVE variable is multipath\n" if ($GITSLAVE =~ /, /);
  die "Destination already exists\n" if (-e $ARGV[2]);
  if ($ARGV[2] =~ m:(.*)/(.*):)
  {
    die "Destination ($ARGV[2]) cannot end in a slash" if (length($2) < 1);
    die "Destination parent ($1) does not exist\n" if (!-d $1);
  }
  my $files = $GITS_DIR."/".$GITSLAVE;
  docmd(qq^git clone "$repos" "$ARGV[2]"^ || die "Could not clone $repos onto $ARGV[2]\n");

  open(W, ">>", $files);
  print W qq^"$ARGV[1]" "$ARGV[2]"\n^;
  close(W);

  if ($ARGV[2] !~ m:/:)
  {
    my ($needadd) = 0;
    $needadd++ if (! -f "$GITS_DIR/.gitignore");
    open(W, ">>", $GITS_DIR."/.gitignore");
    print W qq^$ARGV[2]\n^;
    close(W);
    $files .= " .gitignore";
    docmd(qq^git add .gitignore^) if ($needadd);
  }
  docmd(qq^git commit -m 'gits adding "$ARGV[1]" "$ARGV[2]"' $files^) unless ($OPTIONS{'no-commit'});

  my $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
  if ($curbranch ne "master")
  {
    print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
    docmd(qq^cd "$ARGV[2]"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist\n";
  }
}
elsif ($ARGV[0] eq 'checkouts')
{
  die "Checkouts requires no arguments\n" if ($#ARGV != 0);

  foreach my $group (@slaves)
  {
    if (! -d $group->[1])
    {
      print "gits: Checking out $group->[1]\n" if ($OPTIONS{'verbose'});
      my ($repos) = resolve_repository($group->[0]);
      docmd(qq^git clone "$repos" "@{[$group->[1]]}"^) || die "Could not clone $repos onto @{[$group->[1]]}\n";

      my $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
      if ($curbranch ne "master")
      {
	print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
	docmd(qq^cd "$group->[1]"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist\n";
      }
    }
    else
    {
      print "gits: $group->[1] already exists\n" if ($OPTIONS{'verbose'});
    }
  }
}
elsif ($ARGV[0] eq 'pulls')
{
  shift(@ARGV);
  my ($ok,$okcnt,%msg);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my $oldbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
  my ($warngitslavesync) = 0;

  foreach my $branch (grep(s/branch\.(.*)\.remote=.*/$1/,split(/\n/,getcmd(qq%git config -l%))))
  {
    foreach my $group (@list)
    {
      my $slave = $group->[1];

      if (!-d $slave)
      {
	warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
	$warngitslavesync++;
	next;
      }

      my ($ret, $msg) = getcmd(qq^cd $slave && git checkout $branch && git pull ^.quoteit(@ARGV));
      if ($ret != 0)
      {
	if ($OPTIONS{'press-on'})
	{
	  warn "Aborting gits pulls, now on branch $branch, failed with slave '$slave'.";
	  next;
	}

	my $diemsg = "Failing gits pulls, now on branch $branch, for this branch failed at '$slave'.  ";
	if ($ok)
	{
	  $diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
	}
	else
	{
	  $diemsg .= "(first entry, no other successfully executed)";
	}
	die "$diemsg: $?\n$msg\n";
      }
      $msg =~ s/Switched to branch.*\n//;
      $msg =~ s/Already on \".*\n//;
      $ok .= " $slave";
      $okcnt++;
      push(@{$msg{$msg}}, "$branch\@$slave");
    }
  }
  foreach my $group (@list)
  {
    my $slave = $group->[1];
    next unless (-d $slave);
    docmd(qq^cd $slave && git checkout $oldbranch >&/dev/null^);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }

}
elsif ($ARGV[0] eq 'execs')
{
  shift(@ARGV);
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($branch);
  my (%group,%groupc,%msg);
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($ret, $msg) = getcmd(qq^cd $slave && ^.quoteit(@ARGV));
    if ($ret != 0)
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits execs $ARGV[0], failed with slave '$slave'.";
	next;
      }

      my $diemsg = "Aborting gits execs $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    $ok .= " $slave";
    $okcnt++;

    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
elsif ($ARGV[0] eq 'status')
{
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($branch);
  my (%group,%groupc,%msg);
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 && $ret != 256)
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits $ARGV[0], failed with slave '$slave'.";
	next;
      }

      my $diemsg = "Aborting gits $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    elsif ($ret == 256)
    {
      $returncode = 1;
    }
    $ok .= " $slave";
    $okcnt++;

    my ($premove);
    while ($msg =~ s/(^[^\#].*\n)//)
    {
      $premove .= $1;
    }

    die "gits unexpected status output (missing branch): $msg" unless ($msg =~ s/^\# On branch (.*)\n//);
    $branch = $1 unless ($branch);
    die "Branch ($branch != $1) not identical between @{[$list[0]->[1]]} and $slave\n" unless ($branch eq $1);

    while ($msg =~ s/^(\# \S.*\n)//)
    {
      my ($group) = $1;
      while ($msg =~ s/^(\#\s{2,}\S.*\n)//)
      {
	$groupc{$group}->{$1} = 1;
      }
      die "Could not parse git status output for $slave <$group> <$msg>\n" unless ($msg =~ s/^(\#\s*\n)//);

      while ($msg =~ s/^(\#(?:\s*|(\s{2,}|\t)\S.*)\n)//)
      {
	my ($line) = $1;

	if ($line =~ /([^:]+:\s+)(.*)/s)
	{
	  $line = "$1$slave/$2";
	}
	elsif ($line =~ /(\#\s+)(.+)/)
	{
	  $line = "$1$2 (cd $slave)\n";
	}
	else
	{
	  next if ($line =~ /\#\s*\n/);
	}

	$group{$group} .= $line;
      }
    }

    push(@{$msg{$premove.$msg}}, $slave);
  }

  print "# On branch $branch\n";
  foreach my $group (sort keys %group)
  {
    print $group;
    foreach my $msg (sort keys %{$groupc{$group}})
    {
      print $msg;
    }
    print "#\n";
    print $group{$group};
    print "#\n";
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
else
{
  my ($ok,$okcnt);
  my %msg;

  # This is a sign that you are doing something wrong
  if (-f $ARGV[$#ARGV])
  {
    warn "You have a pathname in a generic gits command, this is a sign that the command\nwill not work since it is unlikely to exist in all modules\nProbably you want to cd to the submodule and run a raw git command\n";
  }

  # Run the command for each module
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 &&
	!($ARGV[0] eq "commit" && $msg =~ /nothing to commit/))
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits $ARGV[0], failed with slave '$slave'.";
	next;
      }

      my $diemsg = "Aborting gits $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    $ok .= " $slave";
    $okcnt++;
    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
exit($returncode);



=pod

=head1 NAME

gits - The git slave repository tool

=head1 SYNOPSIS

gits [--version] [--no-master] [--no-commit] [--press-on] [-v|--verbose]+ [--quiet] [--help] <subcommand> [args]...

=head1 OVERVIEW

gits is a program which assists in assembling a meta-project from a
number of individual git repositories which you own and operate as if
it were one git repository instead of many, similar to how CVS works
by default and svn (v1.5) can be coerced to work.  Some of these
individual git repositories may be part of other meta-projects as
well.

Unfortunately, the functionality provided by git-submodule is not
sufficient for this mode of operation.  Most git commands, like
checkout or commit, do not recursively descend into the submodules so
you are forced to do execute all git commands N+1 times (leading to
pain and mistakes), also, submodules revisions are tracked in the
supermodule so that change to the slave project made outside the
superproject are not automatically seen.  Since git does not allow
partial checkouts, we are left with little alternative.

Thus, to solve these problems gits was born.  Complexity pain is still
involved, but the hope is that it is minimized compared to all of the
other alternatives.

The basic theory is that there are a few sub-commands (inits, clones,
checkouts) which help set up the meta-project for gits operations.
Then, for any git command which is not file specific (git add
<filename>; git reset <filename>; etc), you should use "gits" instead
of "git", and the command will run on all repositories in the project.

=head2 Example Usage

In the following example, we will have the following master
repositories:

  ssh://sourcemaster/src/repos/super.git
  ssh://sourcemaster/src/repos/lib1.git
  ssh://sourcemaster/src/repos/lib2.git


The desired working layout of directories with .git in them on disk
is:

  ..../super
  ..../super/lib1
  ..../super/lib2


=head3 Initialize a gits project

gits init

You run this command in the git directory which will be your top level
master repository (super here).  Typically you would clone this top
level master from some other location which has all of your git
projects.

  --------------------------------------------------
  git clone ssh://sourcemaster/src/repos/super.git super
  cd super
  gits init
  --------------------------------------------------



=head3 Add a slave repository to top level master

  gits clone <repository> <localpath>

Clone the named git repository into the named local directory, and set
it up for further gits operations.

Typically <localpath> would be a path relative to the top level master
checkout, for example, a subdirectory in the top level.

<repository> can also be relative (relative to the URL the top level
master checkout was cloned from).  It may also be an absolute URL.  If
the URL starts with ^, it will use only the method and hostname from
the master's URL.  Otherwise, it will be relative to the fully
qualified path.  We will show both in operation in the example.

 --------------------------------------------------
 gits clones ../lib1.git lib1
 gits clones ^/src/repos/lib2.git lib2
 --------------------------------------------------


=head3 Check out any new slave modules which someone else might have added

  gits checkouts

Go through the list of configured slaves and check out (clone) any which have
not already been retrieved.

  --------------------------------------------------
  gits checkouts
  --------------------------------------------------



=head3 Perform a pull operation for all tracked branches

  gits pulls <args>

For each branch being tracked by the superproject, go through the list
of configured slaves, check yourself out to the branch, perform a pull,
then switch back to the branch you were on.

  --------------------------------------------------
  gits pulls --rebase
  --------------------------------------------------



=head3 Perform a arbtrary command for all tracked branches

  gits execs <command> [args]

For each slave being tracked by the superproject and the superproject itself,
cd to the root of the project directory and execute the listed command.

  --------------------------------------------------
  gits execs gitk
  --------------------------------------------------



=head3 Everything else

All other commands are passed directly though to git, with one command
being run per repository.  Output summerization is performed so that
multiple repositories with the same git output will only have the git
output shown once.  `git status` has a more aggressive summerization
to merge the lists of files in each section.

  Examples:
  --------------------------------------------------
  gits commit -a -m "This is a change"
  gits push
  gits pull
  gits branch testing
  gits checkout testing
  gits diff master testing
  gits status
  gits ....
  --------------------------------------------------

All normal git commands are supported (plus any potential future
commands) but not all commands make sense to run with gits.  One good
example is git-daemon.

=head1 DESCRIPTION

=head2 --no-master

This flag requests that gits only run the listed command on the slave
repositories and NOT the super/master/top repository.  This probably
will not be needed much.

=head2 --no-commit

This flag requests that gits-internal sub-commands, such as inits or
clones should not commit their changes after they made them.

=head2 --press-on

Do not abort when a subsidiary git command fails for most commands,
instead print a message and continue processing.

=head2 --verbose -v

Ask for more information about what is happening.  You may repeat the
flag multiple times to get more information.  Two levels of verbosity
typically prints the underlying commands being executed and the data
being returned from them.

=head2 --quiet

Ask for less information, which currently means discarding the STDERR
of some of the administrative git commands which are executed.

=head2 subcommand args...

Run the specified git command (with associated arguments) on the
repository and all slave repositories.  See OVERVIEW for more
information on specific subcommands.

=head1 BUGS

gits changes directory to the directory where .gitslave exists.
Likewise, when executing most git commands, gits changes directory to
the root of the git slave, so any pathnames being passed in to gits
must be absolute, not relative.  Generally this is only a concern for
pre-generate commit messages or something, you should NOT be passing
files checked into git in a gits command--you will likely get the
wrong result.

=head1 FILES

=head2 .gitslave

The file containing the list of slave repositories (possibly in
relative form) and the directories relative to the master root where
they should be checked out.

=head1 ENVIRONMENT

=head2 $GITSLAVE

Allow overriding on the name of the .gitslave file (for supplimental
activity, the .gitslave file must still exist even if it is not used
for this particular operation).  Also, allows a comma-space seperated
list of files names, the sum of which will be the list of slaves to
use.

An example ".gitslave, .gitslave-extras" would allow an supplimental
list of slaves for unusual activity (e.g. release tagging) to the
normal list.

Alternately, you could play tricks where you only get a subset of the
modules when you don't need to play with everything.

=head1 AUTHOR

Seth Robertson

=head1 REPORTING BUGS

Report bugs to <projectbaka@baka.org>

=head1 COPYRIGHT

Copyright (c) 2008 Seth Robertson.  License is similiar to the GNU
Lesser General Public License version 2.1, see LICENSE.TXT for more
details.

=head1 SEE ALSO

git(1)
