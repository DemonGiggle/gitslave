#!/usr/bin/perl
#
# Support .gitslave files, recursive processing of git commands into slave directories
#
# ++Copyright LIBBK++
#
# Copyright (c) 2003 The Authors. All rights reserved.
#
# This source code is licensed to you under the terms of the file
# LICENSE.TXT in this release for further details.
#
# Mail <projectbaka@baka.org> for further information
#
# --Copyright LIBBK--
#
use strict;
use warnings;
no warnings 'uninitialized';
no warnings 'io';
use Cwd;
use File::Spec;
use constant GITSLAVE => '.gitslave';
use Getopt::Long;


our($GITSLAVE) = $ENV{'GITSLAVE'}||GITSLAVE;
our($GITS_DIR);
our(@slaves);
my($USAGE) = "usage: gits [--version] [--no-master] [--no-commit] [--press-on] [-v|--verbose]+ [--quiet] [--help] <subcommand> [args]...\n";
our(%OPTIONS);
my ($returncode) = 0;
delete($ENV{'GIT_DIR'});


######################################################################
#
# Run a command where we don't care about the output
#
sub docmd($)
{
  my ($cmd) = @_;

  $cmd .= " 2>/dev/null" if ($OPTIONS{'quiet'});
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  system($cmd);
  print STDERR "Command returned: $?\n" if ($OPTIONS{'verbose'} > 1);
  $? == 0;
}



######################################################################
#
# Run a command, retrieving the output
#
sub getcmd($)
{
  my ($cmd) = @_;

  $cmd = "($cmd) 2>&1";
  print STDERR "Running command: `$cmd`\n" if ($OPTIONS{'verbose'} > 1);
  my $out = `$cmd`;
  if ($OPTIONS{'verbose'} > 1)
  {
    my $tout = $out;
    chomp($tout);
    print STDERR "Command returned: ($?, $tout)\n";
  }

  wantarray?($?, $out):$out;
}



######################################################################
#
# Find the absolute path to repository (relatives are relative to local repository)
#
sub resolve_repository($)
{
  my ($repos) = @_;

  # Check for already absolute
  return $repos if ($repos =~ m-^(/|\w+:/)-);

  # Break into method and path sections
  my ($prefix, $suffix) = ("", $repos);
  ($prefix, $suffix) = ($1, $2) if ($repos =~ m-^(\w+:)(.*)-);

  # Find upstream origin URL
  my ($ret, $master_repo) = getcmd("git config remote.origin.url");
  chomp($master_repo);
  die "Could not find git upstream clone which this is relative to\n" unless ($ret == 0 && $master_repo);

  # Nuke trailing .git, if necessary
  $master_repo =~ s:/.git$::;
  my ($mprefix, $msuffix) = ("", $master_repo);
  ($mprefix, $msuffix) = ($1, $2) if ($repos =~ m-^(\w+:(?://[^/]*|))(.*)-);

  # Is this repository-relative? (keep method://host from master)
  if ($repos =~ m:^\^(/.*):)
  {
    return "$mprefix$1";
  }

  # Do we have a replacement method://?  (Seems like an unlikely case)
  if ($prefix)
  {
    $master_repo = $prefix.$msuffix;
  }

  # Handle smushing together, relative paths, etc
  $repos = "$master_repo/$suffix";
  while ($repos =~ s:/\./:/:) {;}
  while ($repos =~ s:/[^/]+?/\.\./:/:) {;}
  while ($repos =~ s-(^\w+://.*)//-$1-g) {;}
  while ($repos !~ m-^\w+://- && $repos =~ s://:/:g) {;}
  $repos;
}



######################################################################
#
# Get list of currently configured slaves
#
sub git_slave_list($)
{
  my ($cmd) = @_;
  my (@gits);

  foreach my $slavefile (split(/, /,$GITSLAVE))
  {
    $slavefile = "$GITS_DIR/$slavefile";
    if (!open(R, "<", $slavefile))
    {
      die "Could not find $slavefile file\n"
	unless (!defined($cmd) or $cmd eq "inits" or $cmd eq "help" or $cmd eq "resolves");
      next;
    }
    my ($lineno) = 1;
    while (<R>)
    {
      next if (/^\s*(?:\#.*)$/);
      die "Bad line $lineno in $slavefile\n" unless (/^\"(.*)\" \"(.*)\"$/);
      push(@gits,[$1, $2]);
    }
    close(R);
  }
  @gits;
}



######################################################################
#
# Add shell quoting to avoid problems
#
sub quoteit(@)
{
  my $str;
  foreach my $item (@_)
  {
    my $qitem = $item;
    $qitem =~ s/([\\\"])/\\$1/;
   $str .= '"'.$qitem.'" ';
  }
  chop($str);
  $str;
}



######################################################################
#
# Checkouts, clone projects listed in .gitslaves
#
sub do_checkouts(;$)
{
  my ($nocheckout)=@_;
  my $curbranch;

  $nocheckout='-n' if ($nocheckout);

  foreach my $group (@slaves)
  {
    my $slave = $group->[1];

    if (! -d $slave)
    {
      print "gits: Checking out $slave\n" if ($OPTIONS{'verbose'});
      my ($repos) = resolve_repository($group->[0]);
      docmd(qq^git clone $nocheckout "$repos" "$slave"^) || die "Could not clone $repos onto $slave\n";

      $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0] unless ($curbranch);
      if ($curbranch ne "master" && $curbranch !~ /no branch/)
      {
	print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
	docmd(qq^cd "$slave"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist for $slave\n";
      }
    }
    else
    {
      print "gits: $slave already exists\n" if ($OPTIONS{'verbose'});
    }
  }
}



######################################################################
#
# git checkout, gits style
#
sub do_checkout($@)
{
  my ($pushprocessing,@args) = @_;
  my ($ret, $msg) = (0, undef);
  my ($slavecnt) = -1;
  my ($ok, $okcnt);
  my (%msg);
  my ($group, $slave) = (undef, ".");

  if (!$OPTIONS{'no-master'})
  {
    my ($cmd) = qq^cd $slave && git checkout ^.quoteit(@args);
    $cmd .= " >&/dev/null" if ($pushprocessing == 2);
    ($ret, $msg) = getcmd($cmd);

    if ($ret == 0)
    {
      # Reload list of slaves, which might have changed due to superproject checkout
      @slaves = git_slave_list("checkout");

      # New list of slaves might have stuff we need to check out
      do_checkouts(1);
    }
  }
  my ($totcnt) = $#slaves + $OPTIONS{'no-master'}?1:2;

  # Tricky: This backwards loop is designed so that the return code processing can be shared between superproject and slaves
  do
  {
    if ($ret != 0)
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits checkout, failed with slave '$slave'.  Pressing on.";
      }
      else
      {
	my $diemsg = "Aborting gits checkout (@{[join(' ',@args)]}), failed at '$slave'.  ";
	if ($ok)
	{
	  $diemsg .= "(ran fine on: $ok, did not run on @{[$totcnt-$okcnt]} other(s); no rollbacks)";
	}
	else
	{
	  $diemsg .= "(first entry, no other successfully executed)";
	}
	die "$diemsg: $?\n$msg\n";
      }
    }
    else
    {
      $ok .= " $slave";
      $okcnt++;
      if ($pushprocessing)
      {
	$msg =~ s/Switched to branch.*\n//;
	$msg =~ s/Already on \".*\n//;
	push(@{$msg{"$args[0]\@$slave"}}, $slave);
      }
      else
      {
	push(@{$msg{$msg}}, $slave);
      }
    }

    # Forward through the slave list
    if (++$slavecnt <= $#slaves)
    {
      $group = $slaves[$slavecnt];
      $slave = $group->[1];

      my ($cmd) = qq^cd $slave && git checkout ^.quoteit(@args);
      $cmd .= " >&/dev/null" if ($pushprocessing == 2);
      ($ret, $msg) = getcmd($cmd);
    }
  } while ($slavecnt <= $#slaves);

  %msg;
}




######################################################################
#
# Main functionality
#
Getopt::Long::Configure("bundling", "no_ignore_case", "no_auto_abbrev", "no_getopt_compat", "require_order");
GetOptions(\%OPTIONS, 'version', 'no-master', 'no-commit', 'press-on', 'verbose|v+', 'quiet', 'help') || die $USAGE;

die "$USAGE" if ($#ARGV < 0 and !($OPTIONS{'version'} or $OPTIONS{'help'}));

# Find GITS_DIR -- location of git slave file
if ($ENV{'GITS_DIR'} && -f $ENV{'GITS_DIR'}."/".GITSLAVE)
{				# Use gitslave location user told us
  $GITS_DIR = $ENV{'GITS_DIR'};
}
else
{				# Probe for gitslave location
  $GITS_DIR = '.';
  my (@S,$dev,$ino) = stat($GITS_DIR);

  do
  {
    if (!-f $GITS_DIR."/".GITSLAVE)
    {
      $GITS_DIR .= '/..';
      $dev = $S[0];
      $ino = $S[1];
      @S = stat($GITS_DIR);
    }
  } while (!-f $GITS_DIR."/".GITSLAVE && $S[0] != $dev && $S[1] != $ino);
}

# All operations are relative to gitslave base
if (-f $GITS_DIR."/".GITSLAVE)
{
  $GITS_DIR = Cwd::realpath($GITS_DIR);
  chdir($GITS_DIR);
  print STDERR "gits: Gitslave found in $GITS_DIR\n" if ($OPTIONS{'verbose'} > 1);
}
else
{
  die "Must inits gits, could not find @{[GITSLAVE]} file.\n"
    unless ($#ARGV < 0 or $ARGV[0] eq 'help' or $ARGV[0] eq 'inits' or $ARGV[0] eq 'resolves');
}

@slaves = git_slave_list($ARGV[0]);

if ($OPTIONS{'version'})
{
  my $version = "{UNTAGGED}";

  # <TRICKY> If the version string is still UNTAGGED, try to run the local
  # git commands to get the current hash and possibly tag; this is used by
  # Makefile to get the correct string to replace it with.  Otherwise, the
  # installation has replaced it with a version; don't mess with it.  Use
  # string concatenation to keep this check from getting replaced. </TRICKY>

  if ($version eq "{" . "UNTAGGED" . "}")
  {
    my ($ret,$hash) = getcmd("git log --pretty=format:%H -n 1");
    chomp($hash);

    my ($dret,$desc) = getcmd("git describe --tags $hash 2>/dev/null");
    if ($dret)
    {
      $desc = "Untagged ($hash)\n";
    }
    else
    {
      # strip out leading tag alphabetic and space, get just the numbers
      $desc =~ s/^[A-Za-z_ -]*([0-9][0-9._-]*[0-9]).*/$1/;
      $desc =~ y=/_=--=;
    }
    print $desc;
  }
  else
  {
    print "gits version $version\n";
    docmd("git --version");
  }
}
elsif ($ARGV[0] eq 'help' or $OPTIONS{'help'})
{
  print "$USAGE";
  use FindBin qw($Bin);
  docmd("pod2text < $Bin/$0 |" .
	"sed -n -e '/^DESCRIPTION/,/^BUGS/H'" .
	" -e '/^BUGS/{x;s/\\n[[:upper:]]*/\\n/g;s/\\n\\n/\\n/;p;}'");
  exit;
}
elsif ($ARGV[0] eq 'inits')
{
  die "Inits requires no arguments\n" if ($#ARGV != 0);
  $GITS_DIR=$ENV{'GITS_DIR'} || ".";
  die "Refusing to init, \$GITSLAVE variable is multipath\n" if ($GITSLAVE =~ /, /);
  die "Refusing to init, $GITS_DIR/@{[$GITSLAVE]} already exists\n" if (-f $GITS_DIR."/".$GITSLAVE);
  open(W, ">", $GITS_DIR."/".$GITSLAVE) || die "Could not create $GITS_DIR/@{[$GITSLAVE]}\n";
  close(W);
  docmd("git add @{[$GITSLAVE]}");
  docmd(qq^git commit -m "gits creating @{[$GITSLAVE]}" @{[$GITSLAVE]}^) unless ($OPTIONS{'no-commit'});
}
elsif ($ARGV[0] eq 'clones')
{
  die "Clone requires two arguments <repository> <directory>\n" if ($#ARGV != 2 || !$ARGV[1] || !$ARGV[2]);
  my ($repos) = resolve_repository($ARGV[1]);
  die "Refusing to clones, \$GITSLAVE variable is multipath\n" if ($GITSLAVE =~ /, /);
  die "Destination already exists\n" if (-e $ARGV[2]);
  if ($ARGV[2] =~ m:(.*)/(.*):)
  {
    die "Destination ($ARGV[2]) cannot end in a slash" if (length($2) < 1);
    die "Destination parent ($1) does not exist\n" if (!-d $1);
  }
  my $files = $GITS_DIR."/".$GITSLAVE;
  docmd(qq^git clone "$repos" "$ARGV[2]"^ || die "Could not clone $repos onto $ARGV[2]\n");

  open(W, ">>", $files);
  print W qq^"$ARGV[1]" "$ARGV[2]"\n^;
  close(W);

  if ($ARGV[2] !~ m:/:)
  {
    my ($needadd) = 0;
    $needadd++ if (! -f "$GITS_DIR/.gitignore");
    open(W, ">>", $GITS_DIR."/.gitignore");
    print W qq^$ARGV[2]\n^;
    close(W);
    $files .= " .gitignore";
    docmd(qq^git add .gitignore^) if ($needadd);
  }
  docmd(qq^git commit -m 'gits adding "$ARGV[1]" "$ARGV[2]"' $files^) unless ($OPTIONS{'no-commit'});

  my $curbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
  if ($curbranch ne "master")
  {
    print qq^Switching "$ARGV[2]" to branch "$curbranch"\n^;
    docmd(qq^cd "$ARGV[2]"; git checkout $curbranch^) || die "Branch inconsistency, branch $curbranch does not exist\n";
  }
}
elsif ($ARGV[0] eq 'checkouts')
{
  die "Checkouts requires no arguments\n" if ($#ARGV != 0);

  do_checkouts();
}
elsif ($ARGV[0] eq 'resolves')
{
  die "Resolves requires at least one arguments\n" if ($#ARGV < 1);

  shift(@ARGV);
  foreach my $repos (@ARGV)
  {
    print resolve_repository($repos)."\n";
  }
}
elsif ($ARGV[0] eq 'pulls')
{
  shift(@ARGV);
  my ($ok,$okcnt,%msg);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my $oldbranch = (grep(s/\s*\*\s+//, split(/\n/,getcmd("git branch"))))[0];
  my ($warngitslavesync) = 0;

  foreach my $branch (grep(s/branch\.(.*)\.remote=.*/$1/,split(/\n/,getcmd(qq%git config -l%))))
  {
    my (%newmsg) = do_checkout(1, $branch);

    foreach my $group (@list)
    {
      my $slave = $group->[1];

      if (!-d $slave)
      {
	warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
	$warngitslavesync++;
	next;
      }

      my ($ret, $msg) = getcmd(qq^cd $slave && git pull ^.quoteit(@ARGV));
      if ($ret != 0)
      {
	if ($OPTIONS{'press-on'})
	{
	  warn "Aborting gits pulls, now on branch $branch, failed with slave '$slave'.";
	  next;
	}

	my $diemsg = "Failing gits pulls, now on branch $branch, for this branch failed at '$slave'.  ";
	if ($ok)
	{
	  $diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
	}
	else
	{
	  $diemsg .= "(first entry, no other successfully executed)";
	}
	die "$diemsg: $?\n$msg\n";
      }
      $msg =~ s/Switched to branch.*\n//;
      $msg =~ s/Already on \".*\n//;
      $ok .= " $slave";
      $okcnt++;
      $msg = $newmsg{$slave}.$msg;
      push(@{$msg{$msg}}, "$branch\@$slave");
    }
  }
  foreach my $group (@list)
  {
    my $slave = $group->[1];

    next unless (-d $slave);
    do_checkout(2, $oldbranch);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }

}
elsif ($ARGV[0] eq 'checkout')
{
  shift(@ARGV);
  my (%msg) = do_checkout(0, @ARGV);

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }

}
elsif ($ARGV[0] eq 'execs')
{
  shift(@ARGV);
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($branch);
  my (%group,%groupc,%msg);
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($ret, $msg) = getcmd(qq^cd $slave && ^.quoteit(@ARGV));
    if ($ret != 0)
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits execs $ARGV[0], failed with slave '$slave'.";
	next;
      }

      my $diemsg = "Aborting gits execs $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    $ok .= " $slave";
    $okcnt++;

    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
elsif ($ARGV[0] eq 'update-remote-url')
{
  my ($cmd,$name,$url) = @ARGV;
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my (%msg);
  my ($warngitslavesync) = 0;

  die "update-remote-url <remote-name> <new-super-url>\n" unless ($name && $url);

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($thisurl) = $url;
    if ($slave ne ".")
    {
      $thisurl = resolve_repository($group->[0]);
    }

    my ($ret, $msg) = getcmd(qq^cd $slave; git config "remote.$name.url" "$thisurl"^);
    if ($ret != 0)
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits $cmd, failed with slave '$slave'.";
	next;
      }

      my $diemsg = "Aborting gits $cmd, failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    $ok .= " $slave";
    $okcnt++;

    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
elsif ($ARGV[0] eq 'status')
{
  my ($ok,$okcnt);
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($branch);
  my (%group,%groupc,%msg);
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 && $ret != 256)
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits $ARGV[0], failed with slave '$slave'.";
	next;
      }

      my $diemsg = "Aborting gits $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    elsif ($ret == 256)
    {
      # git status seems to return 1 (nee wait 256) under all circumstances, so do
      # not even propigate this condition.
      #$returncode = 1;
      1;
    }
    $ok .= " $slave";
    $okcnt++;

    my ($premove);
    while ($msg =~ s/(^[^\#].*\n)//)
    {
      $premove .= $1;
    }

    die "gits unexpected status output (missing branch): $msg" unless ($msg =~ s/^\# On branch (.*)\n//);
    $branch = $1 unless ($branch);
    die "Branch ($branch != $1) not identical between @{[$list[0]->[1]]} and $slave\n" unless ($branch eq $1);

    while ($msg =~ s/^(\# \S.*\n)//)
    {
      my ($group) = $1;
      while ($msg =~ s/^(\#\s{2,}\S.*\n)//)
      {
	$groupc{$group}->{$1} = 1;
      }
      die "Could not parse git status output for $slave <$group> <$msg>\n" unless ($msg =~ s/^(\#\s*\n)//);

      while ($msg =~ s/^(\#(?:\s*|(\s{2,}|\t)\S.*)\n)//)
      {
	my ($line) = $1;

	if ($line =~ /([^:]+:\s+)(.*)/s)
	{
	  $line = "$1$slave/$2";
	}
	elsif ($line =~ /(\#\s+)(.+)/)
	{
	  $line = "$1$2 (cd $slave)\n";
	}
	else
	{
	  next if ($line =~ /\#\s*\n/);
	}

	$group{$group} .= $line;
      }
    }

    push(@{$msg{$premove.$msg}}, $slave);
  }

  print "# On branch $branch\n";
  foreach my $group (sort keys %group)
  {
    print $group;
    foreach my $msg (sort keys %{$groupc{$group}})
    {
      print $msg;
    }
    print "#\n";
    print $group{$group};
    print "#\n";
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
else
{
  my ($ok,$okcnt);
  my %msg;

  # This is a sign that you are doing something wrong
  if (-f $ARGV[$#ARGV])
  {
    warn "You have a pathname in a generic gits command, this is a sign that the command\nwill not work since it is unlikely to exist in all modules\nProbably you want to cd to the submodule and run a raw git command\n";
  }

  # Run the command for each module
  my (@list) = @slaves;
  unshift(@list,[undef,"."]) unless ($OPTIONS{'no-master'});
  my ($warngitslavesync) = 0;

  foreach my $group (@list)
  {
    my $slave = $group->[1];

    if (!-d $slave)
    {
      warn "Missing one or more git slaves including $slave, consider gits checkouts.  Skipping.\n" unless ($warngitslavesync);
      $warngitslavesync++;
      next;
    }

    my ($ret, $msg) = getcmd(qq^cd $slave && git ^.quoteit(@ARGV));
    if ($ret != 0 &&
	!($ARGV[0] eq "commit" && $msg =~ /nothing to commit/))
    {
      if ($OPTIONS{'press-on'})
      {
	warn "Failing gits $ARGV[0], failed with slave '$slave'.";
	next;
      }

      my $diemsg = "Aborting gits $ARGV[0], failed at '$slave'.  ";
      if ($ok)
      {
	$diemsg .= "(ran fine on: $ok, did not run on @{[$#list-$okcnt]} other(s); no rollbacks)";
      }
      else
      {
	$diemsg .= "(first entry, no other successfully executed)";
      }
      die "$diemsg: $?\n$msg\n";
    }
    $ok .= " $slave";
    $okcnt++;
    push(@{$msg{$msg}}, $slave);
  }

  foreach my $msg (sort { $#{$msg{$a}} <=> $#{$msg{$b}} } keys %msg)
  {
    print "On: ", join(', ',@{$msg{$msg}}), ":\n";
    $msg =~ s/^/  /mg if (length($msg));
    print $msg;
  }
}
exit($returncode);



=pod

=head1 NAME

gits - The git slave repository tool

=head1 SYNOPSIS

gits [--version] [--no-master] [--no-commit] [--press-on] [-v|--verbose]+ [--quiet] [--help] <subcommand> [args]...

=head1 OVERVIEW

gits is a program which assists in assembling a meta-project from a
number of individual git repositories which you own and operate as if
it were one git repository instead of many, similar to how CVS works
by default and svn (v1.5) can be coerced to work.  Some of these
individual git repositories may be part of other meta-projects as
well.

Unfortunately, the functionality provided by git-submodule is not
sufficient for this mode of operation.  Most git commands, like
checkout or commit, do not recursively descend into the submodules so
you are forced to do execute all git commands N+1 times (leading to
pain and mistakes), also, submodules revisions are tracked in the
supermodule so that change to the slave project made outside the
superproject are not automatically seen.  Since git does not allow
partial checkouts, we are left with little alternative.

Thus, to solve these problems gits was born.  Complexity pain is still
involved, but the hope is that it is minimized compared to all of the
other alternatives.

The basic theory is that there are a few sub-commands (inits, clones,
checkouts) which help set up the meta-project for gits operations.
Then, for any git command which is not file specific (git add
<filename>; git reset <filename>; etc), you should use "gits" instead
of "git", and the command will run on all repositories in the project.

=head2 Example Usage

In the following example, we will have the following master
repositories:

  ssh://sourcemaster/src/repos/super.git
  ssh://sourcemaster/src/repos/lib1.git
  ssh://sourcemaster/src/repos/lib2.git


The desired working layout of directories with .git in them on disk
is:

  ..../super
  ..../super/lib1
  ..../super/lib2


=head3 Initialize a gits project

gits init

You run this command in the git directory which will be your top level
master repository (super here).  Typically you would clone this top
level master from some other location which has all of your git
projects.

  --------------------------------------------------
  git clone ssh://sourcemaster/src/repos/super.git super
  cd super
  gits init
  --------------------------------------------------



=head3 Add a slave repository to top level master

  gits clone <repository> <localpath>

Clone the named git repository into the named local directory, and set
it up for further gits operations.

Typically <localpath> would be a path relative to the top level master
checkout, for example, a subdirectory in the top level.

<repository> can also be relative (relative to the URL the top level
master checkout was cloned from).  It may also be an absolute URL.  If
the URL starts with ^, it will use only the method and hostname from
the master's URL.  Otherwise, it will be relative to the fully
qualified path.  We will show both in operation in the example.

 --------------------------------------------------
 gits clones ../lib1.git lib1
 gits clones ^/src/repos/lib2.git lib2
 --------------------------------------------------


=head3 Check out any new slave modules which someone else might have added

  gits checkouts

Go through the list of configured slaves and check out (clone) any which have
not already been retrieved.

  --------------------------------------------------
  gits checkouts
  --------------------------------------------------



=head3 Perform a pull operation for all tracked branches

  gits pulls <args>

For each branch being tracked by the superproject, go through the list
of configured slaves, check yourself out to the branch, perform a pull,
then switch back to the branch you were on.

  --------------------------------------------------
  gits pulls --rebase
  --------------------------------------------------



=head3 Perform a arbtrary command for all tracked branches

  gits execs <command> [args]

For each slave being tracked by the superproject and the superproject itself,
cd to the root of the project directory and execute the listed command.

  --------------------------------------------------
  gits execs gitk
  --------------------------------------------------



=head3 Print out the URLs for arbitrary repositories like clones takes

  gits resolves <repository>...

Go through the same process that gits uses for resolving relative
repository URLs into absolute URLs, for debugging and certain porting
efforts.

  --------------------------------------------------
  gits resolves ../otherpos
  --------------------------------------------------



=head3 Update the URL a remote repository points at

  gits update-remote-url <remote-name> <url>

Update the super-project's remote.name.url using the url and remote
name listed above.  Then go though each slave repository and update
its url using the normal relative url mechanism.

Very useful when making another copy of a local repository mirroring a
remote repository which you wish to have the copy also point to the
remote repository.

  --------------------------------------------------
  gits update-remote-url origin ssh://git/src/git
  --------------------------------------------------



=head3 Everything else

All other commands are passed directly though to git, with one command
being run per repository.  Output summerization is performed so that
multiple repositories with the same git output will only have the git
output shown once.  `git status` has a more aggressive summerization
to merge the lists of files in each section.

  Examples:
  --------------------------------------------------
  gits commit -a -m "This is a change"
  gits push
  gits pull
  gits branch testing
  gits checkout testing
  gits diff master testing
  gits status
  gits ....
  --------------------------------------------------

All normal git commands are supported (plus any potential future
commands) but not all commands make sense to run with gits.  One good
example is git-daemon.

=head1 DESCRIPTION

=head2 --no-master

This flag requests that gits only run the listed command on the slave
repositories and NOT the super/master/top repository.  This probably
will not be needed much.

=head2 --no-commit

This flag requests that gits-internal sub-commands, such as inits or
clones should not commit their changes after they made them.

=head2 --press-on

Do not abort when a subsidiary git command fails for most commands,
instead print a message and continue processing.

=head2 --verbose -v

Ask for more information about what is happening.  You may repeat the
flag multiple times to get more information.  Two levels of verbosity
typically prints the underlying commands being executed and the data
being returned from them.

=head2 --quiet

Ask for less information, which currently means discarding the STDERR
of some of the administrative git commands which are executed.

=head2 subcommand args...

Run the specified git command (with associated arguments) on the
repository and all slave repositories.  See OVERVIEW for more
information on specific subcommands.

=head1 BUGS

gits changes directory to the directory where .gitslave exists.
Likewise, when executing most git commands, gits changes directory to
the root of the git slave, so any pathnames being passed in to gits
must be absolute, not relative.  Generally this is only a concern for
pre-generate commit messages or something, you should NOT be passing
files checked into git in a gits command--you will likely get the
wrong result.

=head1 FILES

=head2 .gitslave

The file containing the list of slave repositories (possibly in
relative form) and the directories relative to the master root where
they should be checked out.

=head1 ENVIRONMENT

=head2 $GITSLAVE

Allow overriding on the name of the .gitslave file (for supplimental
activity, the .gitslave file must still exist even if it is not used
for this particular operation).  Also, allows a comma-space seperated
list of files names, the sum of which will be the list of slaves to
use.

An example ".gitslave, .gitslave-extras" would allow an supplimental
list of slaves for unusual activity (e.g. release tagging) to the
normal list.

Alternately, you could play tricks where you only get a subset of the
modules when you don't need to play with everything.

=head1 AUTHOR

Seth Robertson

=head1 REPORTING BUGS

Report bugs to <projectbaka@baka.org>

=head1 COPYRIGHT

Copyright (c) 2008 Seth Robertson.  License is similiar to the GNU
Lesser General Public License version 2.1, see LICENSE.TXT for more
details.

=head1 SEE ALSO

git(1)
