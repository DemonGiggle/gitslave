* Add -n, --dry-run option to display, but not run, subcommands

This is especially useful when trying to understand how this all works.
Implementing this could be tricky when the output from a git command is
used to determine what other commands will be run.  We might need an extra
argument to getcmd() that says 'this command won't change anything, and I
need the output' and use this to selectively run certain safe commands even
in -n mode.


* Push is very slow

At the cost of thoroughness (missing unpushed commits on branches other
than current), a command/option that only does a git push when git status
shows the local repository ahead of the remote branch.


* Pull is very slow

Because of the need to contact many repositories (setting up an ssh session
for each one), doing a pull can be very slow.

Possible solution: run subsidiary pulls in parallel (up to some limit
specified by -j/--jobs) with default value configured in master repository.


* Inconsistent state on an abort is bad

This can happen most easily on a push if someone else managed to sneak
in a push of their own between your last pull and the current push
attempt.  This is a race condition.

Possible solution: use a lock file in the top/supermodule managed by
gits with an automatic timeout.  Create the lock beforehand, push top,
push everything else, delete lock, push top.

Problems: This file will have MANY commits in it, assumes synchronized
clocks, and can still have the race if clocks are not synchronized,
the push gets stalled/takes longer than expected, etc.


* On an abort, you don't get to see the output of what worked, so
  recovery is made harder.

It can be added, but seemingly it is only going to make things more
cluttered and confused.


* Complete log history not available in superproject

We could gather slave history and put it in changelog or something, or
even a special superproject commit, but this would not work if another
superproject made the change.

One bad side-effect of this is that gitk does not have a global
purview of what is happening.

Alternately, we could have it pull all logs since the last checkpoint.


* Interactive commit messages not available

You cannot nicely use gits commit and have the system put up an editor
for you to type your commit message in.  Or rather, you can, but you
will have to retype once per slave with a change.

If we could detect this state, we could put up the editor ourselves,
make a unified template with unified status, and then add the -F flag
to point at the newly created message
