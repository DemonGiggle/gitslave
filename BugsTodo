
* Inconsistent state on an abort is bad

This can happen most easily on a push if someone else managed to sneak
in a push of their own between your last pull and the current push
attempt.  This is a race condition.

Possible solution: use a lock file in the top/supermodule managed by
gits with an automatic timeout.  Create the lock beforehand, push top,
push everything else, delete lock, push top.

Problems: This file will have MANY commits in it, assumes synchronized
clocks, and can still have the race if clocks are not synchronized,
the push gets stalled/takes longer than expected, etc.


* On an abort, you don't get to see the output of what worked, so
  recovery is made harder.

It can be added, but seemingly it is only going to make things more
cluttered and confused.


* Complete log history not available in superproject

We could gather slave history and put it in changelog or something, or
even a special superproject commit, but this would not work if another
superproject made the change.

One bad side-effect of this is that gitk does not have a global
purview of what is happening.

Alternately, we could have it pull all logs since the last checkpoint.


* Interactive commit messages not available

You cannot nicely use gits commit and have the system put up an editor
for you to type your commit message in.  Or rather, you can, but you
will have to retype once per slave with a change.

If we could detect this state, we could put up the editor ourselves,
make a unified template with unified status, and then add the -F flag
to point at the newly created message
