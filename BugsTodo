* Add -n, --dry-run option to display, but not run, subcommands

This is especially useful when trying to understand how this all works.
Implementing this could be tricky when the output from a git command is
used to determine what other commands will be run.  We might need an extra
argument to getcmd() that says 'this command won't change anything, and I
need the output' and use this to selectively run certain safe commands even
in -n mode.


* Gits clean -fdx should provide more warning about deleting unlisted slaves

While gits clean checks for slave directories (that would otherwise get
removed by git clean -fdx) it should double check for .git directories
inside any other subdirectories that are not listed as slaves.  Especially
in a case where GITSLAVE environment variable is used to select different
sub- and super-sets of slaves, there may be slaves present that aren't in
the currently active set, and you probably (although not always) don't want
to remove them.  Another -f argument (or maybe -F?) should be necessary to
force their removal.


* Git coloring and paging are ineffective for gits

Running `gits diff` doesn't provide automatic coloring or paging, since the
output of each git diff command is directed into a pipe.  Since the diff
command is unlikely to be collapsible (except if it is entirely empty),
having the output collapsing isn't that useful.  Add -C, --no-collapse
option to disable output duplication collapse

Another way to do this might be to have a direct subcommand; you could then
say `gits direct git diff` to get direct (uncollapsed) git diff output.

Alternately, have an option to force automatic coloring, and (another to)
enable automatic paging for gits output (the latter might well be useful
for many commands).


* Relative paths aren't handled intelligently by gits add

Right now, `gits add submod/some/thing.c` will just abort, telling you that
you are trying to do something very tricky that needs to be handled
manually.  Of course, it is tricky enough that the user will probably botch
it too, especially if there are multiple submodules (think rh-dist/anaconda
and jtt).  There should be an intelligent gits add that does something
other than fail - it has all the necessary information to figure out the
appropriate slave modules from the pathname.


* Gits populate doesn't work correctly on non-master branch

When running gits populate on a non-master branch, the checkout fails
because the local branch doesn't exist:

$ gits branch
On: ., admincmd, alarmer, antura-dist, arpd, awb-ids, binary-plug, bkmk, conn-plug, constfile-plug, copy-plug, csv-plug, dbtools, exec-plug, genup, libbk, libclc, libdnet, libevent, libpcap, meta-accum-plug, middleearth, miscfeatures-plug, netpcap_tool, network-plug, pcap-plug, pcap-ringdir, perlbk, perlmods, pg-proto-plug, pg-tagset-plug, postgres-plug, postgres, sd2004-plug, ssltools, st-plug, sysd-licensing, sysd-php, tcpdump, tcpslice, upad-plug:
  * HADIT-1

$ gits populate
Initialized empty Git repository in /proj/udell/dupuy/awb/rh-dist/.git/
Checking out files: 100% (152/152), done.
Switching "" to branch "HADIT-1"
error: pathspec 'HADIT-1' did not match any file(s) known to git.
Branch inconsistency, branch HADIT-1 does not exist for rh-dist

This might be aggravated by fact that I have deleted the master branch for
this checkout - I don't need it, and it speeds up pulls, but I suspect the
problem would still exist.

    The problem seems to be if master has a local branch (HADIT-1) and
    you perhaps adjust the GITSLAVE or .gitslave (or failed to create
    the local branch using gits), git populate fails because the new
    children do not have the HADIT-1 branch.

    The fix did not handle this case, it created the HADIT-1 branch on the
    top level without the request of the user, but then failed to create
    the branch for any of the children.

    In any case, gits has no business creating branches without an
    explicit request.  golden-build is attempting to check out a tag
    (a perfectly valid way to operate) but this change made the top
    level attempt to create a local branch from a tag, which really
    cannot work. .  What I could see being legal would be, if the top
    level repo had a local branch and the slave did not, perhaps
    automatically creating the local branch for the slave, but even
    this is fallable.  Branch and tag operations are really important
    to create correctly the first time instead of updating them
    piecemeal.  Expecting gits to intuit what the user wanted to have
    happen is likely to be very challenging and error-prone.


* Pull is very slow

Because of the need to contact many repositories (setting up an ssh session
for each one), doing a pull can be very slow.

This is mitigated by use of -p|--parallel=COUNT option, which runs
subsidiary pulls in parallel, assuming that you have Parallel::Iterate from
CPAN installed.  It is an imperfect solution, since there are some race
conditions, especially if you re-use ssh sessions by adding the following
to your .ssh/config:

Host git
	ControlMaster auto
	ControlPath ~/.ssh/master-%r@%h:%p

and either manually running (ssh -N git&) or wrapping gits in a shell
script that starts a control master ssh if needed.  (Check an existing
control path for liveness with `ssh -S $PATH -O check localhost`, and use
`ssh -S $PATH -O exit localhost` to cleanly terminate one started up for
gits operation.)


* Pulls is even slower

Because it needs to run a pull on each branch, it slows it down even
more.  In theory, only the first operation needs to communicate with
the network.  The others should be able to just do a local
merge/rebase.  However, the manual page has tantalizing hints that pull
has some magic interaction with merge/rebase which might make that
a slightly different operation.


* Inconsistent state on an abort is bad

This can happen most easily on a push if someone else managed to sneak
in a push of their own between your last pull and the current push
attempt.  This is a race condition.

Possible solution: use a lock file in the top/supermodule managed by
gits with an automatic timeout.  Create the lock beforehand, push top,
push everything else, delete lock, push top.

Problems: This file will have MANY commits in it, assumes synchronized
clocks, and can still have the race if clocks are not synchronized,
the push gets stalled/takes longer than expected, etc.


* On an abort, you don't get to see the output of what worked, so
  recovery is made harder.

It can be added, but seemingly it is only going to make things more
cluttered and confused.


* awb/bkmk requires complete rebuild after pulls with multiple branches

In a repository with multiple local tracking branches, `gits pulls` will
perform a `git checkout` for each branch.  One undesirably side-effect of
this is that awb/bkmk will detect a (timestamp?) change to the configure
script or its results, and re-run the entire Baka configure script again.


* Complete log history not available in superproject

We could gather slave history and put it in changelog or something, or
even a special superproject commit, but this would not work if another
superproject made the change.

One bad side-effect of this is that gitk does not have a global
purview of what is happening.

Alternately, we could have it pull all logs since the last checkpoint.


* Interactive commit messages not available

You cannot nicely use gits commit and have the system put up an editor
for you to type your commit message in.  Or rather, you can, but you
will have to retype once per slave with a change.

If we could detect this state, we could put up the editor ourselves,
make a unified template with unified status, and then add the -F flag
to point at the newly created message


* Collapse of redundant messages in output stymied by hash ids

In quite a few commands the presence of different hash ids in each slave
module generates insignificant differences in the output that prevent them
from being coalesced.  There is better support for eliminating these in the
gits pulls command (even there it is probably not complete) but not really
any for other commands, especially pass-throughs.
