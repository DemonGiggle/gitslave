* gits attach could allow existant destination under one condition

Currently attach fails if the destination location exists.  This is a
good double-check, but there is one case where this could be
permissible.  If the destination location is a git repo and the git
repo's remote origin URL is consistent with the (possibly relative)
URL provided on the attach line.


* Pager support on output

Currently any commands which are supposed to run through a pager when
using git are depagerized when sent through gits, and gits has no
pager support.  It is not perfectly clear how this could be resolved
cleanly.


* Recursive project support

It would be very nice if the #include syntax in .gitslave files
could support recursive projects.  The main limiting factor right
now is that relative URLs are being interpolated relative to the
super-super-base, not the most local superproject's base (which in turn
might be relative to the super-super-base, but that doesn't help
the sub-sub-base determination).


* Shallow clone/sparse checkout support for subprojects

Some people want to have shallow clones or sparse checkouts.  This
cannot easily be done for submodules, but seems fairly reasonable for
gitslave.  We would just need some magic to use the right arguments
(presumably shallow would be a .git/config thing, and sparse would be
a .gitslave config thing).


* Allow API to move submodules

There is a workaround of removing it and re-adding it, but allowing
direct movement might be useful.


* Add alternative URLs

Allow multiple URLs to be specified for a particular resource and
during populate, select the first one which is reachable.  Ideally,
allow re-running populate to update the currently used URL for origin
if the reachable URL might have changed.

Use case might be for an on-laptop repo which might sometimes be
directly attached and other times might need to go through an ssh
tunnel or otherwise have various tricks.


* Add "gits branch --set-upstream" support

Currently there is no support for changing upstream repositories via
--set-upstream with the correct relative URLs.  See update-remote-url.


* Add -n, --dry-run option to display, but not run, subcommands

This is especially useful when trying to understand how this all works.
Implementing this could be tricky when the output from a git command is
used to determine what other commands will be run.  We might need an extra
argument to getcmd() that says 'this command won't change anything, and I
need the output' and use this to selectively run certain safe commands even
in -n mode.


* Gits clean -fdx should provide more warning about deleting unlisted slaves

While gits clean checks for slave directories (that would otherwise
get removed by git clean -fdx) it should double check for .git
directories inside any other subdirectories that are not listed as
slaves.  Especially in a case where GITSLAVE environment variable is
used to select different sub- and super-sets of slaves or you check
out alternate .gitslave files with a different set of slaves, there
may be slaves present that aren't in the currently active set, and you
probably (although not always) don't want to remove them.  Another -f
argument (or maybe -F?) should be necessary to force their removal.


* Git coloring and paging are ineffective for gits

Running `gits diff` doesn't provide automatic coloring or paging, since the
output of each git diff command is directed into a pipe.  Since the diff
command is unlikely to be collapsible (except if it is entirely empty),
having the output collapsing isn't that useful.  Add -C, --no-collapse
option to disable output duplication collapse

Another way to do this might be to have a direct subcommand; you could then
say `gits direct git diff` to get direct (uncollapsed) git diff output.

Alternately, have an option to force automatic coloring, and (another to)
enable automatic paging for gits output (the latter might well be useful
for many commands).


* Relative paths aren't handled intelligently by gits add

Right now, `gits add submod/some/thing.c` will just abort, telling you that
you are trying to do something very tricky that needs to be handled
manually.  Of course, it is tricky enough that the user will probably botch
it too, especially if there are multiple submodules (think rh-dist/anaconda
and jtt).  There should be an intelligent gits add that does something
other than fail - it has all the necessary information to figure out the
appropriate slave modules from the pathname.


* Gits populate doesn't work correctly on non-master branch

When running gits populate on a non-master branch, the checkout fails
because the local branch doesn't exist:

$ gits branch
On: ., foo, bar, baz, biff, bard:
  * HATID-1

$ gits populate
Initialized empty Git repository in /proj/ell/dup/wb/foo/.git/
Checking out files: 100% (152/152), done.
Switching "" to branch "HATID-1"
error: pathspec 'HATID-1' did not match any file(s) known to git.
Branch inconsistency, branch HATID-1 does not exist for foo

This might be aggravated by fact that I have deleted the master branch for
this checkout - I don't need it, and it speeds up pulls, but I suspect the
problem would still exist.

    The problem seems to be if master has a local branch (HATID-1) and
    you perhaps adjust the GITSLAVE or .gitslave (or failed to create
    the local branch using gits), git populate fails because the new
    children do not have the HATID-1 branch.

    The fix did not handle this case, it created the HATID-1 branch on the
    top level without the request of the user, but then failed to create
    the branch for any of the children.

    In any case, gits has no business creating branches without an
    explicit request.  gbuild is attempting to check out a tag (a
    perfectly valid way to operate) but this change made the top level
    attempt to create a local branch from a tag, which really cannot
    work. .  What I could see being legal would be, if the top level
    repo had a local branch and the slave did not, perhaps
    automatically creating the local branch for the slave, but even
    this is fallable.  Branch and tag operations are really important
    to create correctly the first time instead of updating them
    piecemeal.  Expecting gits to intuit what the user wanted to have
    happen is likely to be very challenging and error-prone.


* Pull is very slow

Because of the need to contact many repositories (setting up an ssh session
for each one), doing a pull can be very slow.

This is mitigated by use of -p|--parallel=COUNT option, which runs
subsidiary pulls in parallel, assuming that you have Parallel::Iterate from
CPAN installed.  It is an imperfect solution, since there are some race
conditions, especially if you re-use ssh sessions by adding the following
to your .ssh/config:

Host git
	ControlMaster auto
	ControlPath ~/.ssh/master-%r@%h:%p

and either manually running (ssh -N git&) or wrapping gits in a shell
script that starts a control master ssh if needed.  (Check an existing
control path for liveness with `ssh -S $PATH -O check localhost`, and use
`ssh -S $PATH -O exit localhost` to cleanly terminate one started up for
gits operation.)


* Pulls is even slower

Because it needs to run a pull on each branch, it slows it down even
more.  In theory, only the first operation needs to communicate with
the network.  The others should be able to just do a local
merge/rebase.  However, the manual page has tantalizing hints that pull
has some magic interaction with merge/rebase which might make that
a slightly different operation.

I no longer believe there is any magic in merging (or rebasing) on
other branches.  However, figuring out the tracking relationship
externally is likely to fail.  While we can `git remote show <remote>`
and parse to get the right bits, this requires figuring out what the
remote of interest is.  Still, doing a full parse of the `gits pulls`
command line, computing defaults, and then doing the correct merge is
likely to be a little challenging.  At least we can restrict pulls to
the simple case of "gits pulls [--rebase] [<remote>]" since the other
cases don't seem interesting.  Still, computing the default repository
is likely to be annoying since it can vary on a branch-by-branch
basis.


* Inconsistent state on an abort is bad

This can happen most easily on a push if someone else managed to sneak
in a push of their own between your last pull and the current push
attempt.  This is a race condition.

Possible solution: use a lock file in the top/supermodule managed by
gits with an automatic timeout.  Create the lock beforehand, push top,
push everything else, delete lock, push top.

Problems: This file will have MANY commits in it, assumes synchronized
clocks, and can still have the race if clocks are not synchronized,
the push gets stalled/takes longer than expected, etc.


* On an abort, you don't get to see the output of what worked, so
  recovery is made harder.

It can be added, but seemingly it is only going to make things more
cluttered and confused.

Should we stick it in a tmp file somewhere to be cleaned up on the
next gits operation?


* wb/bkmk requires complete rebuild after pulls with multiple branches

In a repository with multiple local tracking branches, `gits pulls` will
perform a `git checkout` for each branch.  One undesirably side-effect of
this is that wb/bkmk will detect a (timestamp?) change to the configure
script or its results, and re-run the entire Baka configure script again.


* Complete log history not available in superproject

We could gather slave history and put it in changelog or something, or
even a special superproject commit, but this would not work if another
superproject made the change.

One bad side-effect of this is that gitk does not have a global
purview of what is happening.

Alternately, we could have it pull all logs since the last checkpoint.

The following gives you unifiedish history since the last tag.

gits exec sh -c 'git log -n 10 --pretty=oneline  --abbrev-commit `git describe --match "*-20[01][0-9]*" --long  | sed "s/-[0-9][0-9]*-[a-z0-9][a-z0-9]*\$//"`..HEAD'


* Interactive commit messages not available

You cannot nicely use gits commit and have the system put up an editor
for you to type your commit message in.  Or rather, you can, but you
will have to retype once per slave with a change.

If we could detect this state, we could put up the editor ourselves,
make a unified template with unified status, and then add the -F flag
to point at the newly created message


* Collapse of redundant messages in output stymied by hash ids

In quite a few commands the presence of different hash ids in each slave
module generates insignificant differences in the output that prevent them
from being coalesced.  There is better support for eliminating these in the
gits pulls command (even there it is probably not complete) but not really
any for other commands, especially pass-throughs.
